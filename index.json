[{"content":"Pada artikel ini, saya akan menjelaskan bagaimana cara membuat variabel, array, dan lain-lain yang berkaitan, pada shell Bash.\nSeperti yang sudah pernah dibahas pada artikel Belajar Bash Scripting lain, bahwa tentunya Bash Scripting yang dibahas ini tidaklah POSIX-compliant atau istilahnya Bashism.\nAturan penamaan Dalam membuat variabel atau array, ketentuan dalam pemberian nama adalah sebagai berikut:\n Tidak diawali dengan angka. Tidak diawali atau mengandung tanda pentung, tanda @, tanda pagar #. Tidak mengandung asterisk (*). Variabel dengan huruf kapital seluruhnya, dikhususkan untuk variabel internal shell dan varibel environment.  Contoh:\n1variabel # salah !variabel # salah @variabel # salah vari*abel # salah #variabel # salah vari#abel # salah vari!abel # salah vari@abel # salah SHELL # sudah digunakan sebagai internal variabel variabel # benar Variabel # benar vAriabel # benar vari_abel # benar _variabel # benar vari4bel # benar variabel1 # benar Variabel Membuat variabel Pada Bash shell, variabel bisa dibuat dengan cara seperti ini:\n# Tanpa petik var=string # Petik var=\u0026#34;string\u0026#34; # Petik tunggal var=\u0026#39;string\u0026#39; Perbedaan mengenai penggunaan tanda petik dan petik tunggal akan dijelaskan nanti.\nPerlu diperhatikan bahwa untuk membuat variabel, tidak boleh ada spasi diantara tanda =, misalnya:\n# Salah var = \u0026#34;string\u0026#34; var= \u0026#34;string\u0026#34; var =\u0026#34;string\u0026#34; Melihat isi variabel Isi variabel bisa dilihat dengan command echo atau printf:\n$ var=\u0026#34;Bismillah\u0026#34; $ echo \u0026#34;$var\u0026#34; Bismillah $ printf \u0026#39;%s\\n\u0026#39; \u0026#34;$var\u0026#34; Bismillah Mengisi variabel dari output suatu command Suatu variabel bisa diisi dengan output dari suatu command tertentu dengan menggunakan 2 cara:\n Menggunakan backticks `\u0026hellip;` Menggunakan command substitution $(...)  Contoh:\nvar=`uname -r` var=$(uname -r) Cara kedua lebih disarankan karena 1) backticks sudah dianggap telah deprecated (ditinggalkan), 2) command substitution memungkinkan untuk digunakan secara berlapis. Misal:\nvar=$(ls -1 $(pwd)) Menambah isi variabel (append) Menambah isi variabel (yang berupa string) bisa dilakukan seperti membuat variabel tersebut namun tidak sekedar dengan tanda = saja, tetapi dengan +=, contoh:\n$ var=Hello $ echo \u0026#34;$var\u0026#34; Hello $ var+=\u0026#34;, World!\u0026#34; $ echo \u0026#34;$var\u0026#34; Hello, World! Kalkulasi aritmatis pada variabel (integer) Membuat variabel berupa hasil kalkulasi 2 bilangan bulat (atau lebih), bisa dilakukan dengan dua tanda kurung $((...))\n$ bil1=5 $ bil2=9 $ hasil=$((bil1 + bil2)) $ echo $hasil 14 $ kali=$((bil1 * bil2)) $ echo $kali 45 Variabel readonly Variabel readonly adalah variabel yang tidak bisa berubah setelah ditetapkan isinya, sama dengan konsep variabel konstan pada keumuman bahasa pemrograman.\n# cara 1 $ readonly var=string # cara 2 $ declare -r var=string $ var=strong bash: var: readonly variable Variabel lokal Variabel lokal adalah variabel yang ruang lingkupnya hanya pada suatu fungsi saja. Ketika dipanggil diluar fungsi tersebut, maka variabel yang dipanggil tersebut adalah variabel yang berbeda.\n$ var=xyz $ fungsi() { local var=abc # atau declare var=abc echo \u0026#34;$var\u0026#34; } $ echo \u0026#34;$var\u0026#34; xyz $ fungsi abc Membuat variabel dengan printf Command printf adalah salah satu tool builtin pada shell Bash. Selain berfungsi seperti echo, printf juga bisa digunakan untuk menetapkan suatu variabel.\n$ printf -v var \u0026#39;%s\\n\u0026#39; string $ echo \u0026#34;$var\u0026#34; string Membuat variabel berdasarkan input pengguna Yang dimaksud disini adalah membuat variabel dengan cara interaktif, yaitu membutuhkan inputan dari pengguna shell. Seperti \u0026ldquo;Siapa namamu?\u0026rdquo;, kemudian pengguna mengisikan namanya.\n$ read -r -p \u0026#34;Siapa namamu? \u0026#34; nama Siapa namamu? Fulan bin Fulan $ echo \u0026#34;Namaku: $nama\u0026#34; Namaku: Fulan bin Fulan Flag -r diatas berfungsi untuk menghindari backslash dari melakukan escaping karakter apapun. Sedangkan -p berfungsi untuk mem-print serangkaian kata yang sudah ditentukan sebelum melakukan read. Ini guna menghemat dari penggunaan echo sebelum read.\nKasus penggunaan tool read ini diantaranya adalah seperti melakukan konfirmasi Yes/No sebelum menjalankan command tertentu; atau membuat script yang interaktif, dan sebagainya.\nArray Diantara shell-shell yang ada, diantaranya ada yang mendukung array dan ada yang tidak. Bash adalah salah satu yang mendukung array. Jenis array yang bisa dibuat pada shell bash adalah Associative Array dan Indexed Array\nArray terindeks (indexed array) Yang dimaksud dengan indexed array adalah array yang tiap anggotanya memiliki nomor indeks masing-masing yang dimulai dari nol (zero indexed). Cara membuatnya adalah seperti berikut:\n# cara 1 array=(satu dua tiga) # cara 2 declare -a array=(satu dua tiga) Array asosiatif (associative array) Associative array, adalah jenis array yang memiliki key dan value. Cara membuat:\n$ declare -A array=([nama]=Fulan [kota]=Surabaya [pendidikan]=S1) $ array[status]=\u0026#34;Lajang\u0026#34; $ array[pekerjaan]=\u0026#34;Swasta\u0026#34; Melihat isi array Untuk melihat seluruh isi array:\nIndexed array $ echo \u0026#34;${array[@]}\u0026#34; satu dua tiga Untuk mengakses salah satu anggota array:\n$ echo \u0026#34;${array[1]}\u0026#34; dua Associative array Hampir sama dengan array terindeks, untuk melihat value tiap anggota array asosiatif:\n$ echo \u0026#34;${array[@]}\u0026#34; Fulan Surabaya S1 Lajang Swasta Untuk melihat seluruh key dari tiap anggota array:\n$ echo \u0026#34;${!array[@]}\u0026#34; nama kota pendidikan status pekerjaan Untuk melihat value dari key tertentu:\n$ echo \u0026#34;${array[status]}\u0026#34; Lajang Mengakses array menggunakan loop Mengakses array menggunakan loop memungkinkan untuk melakukan sesuatu terhadap tiap-tiap isi array, baik itu array asosiatif atau terindeks.\n# _Indexed_ array $ arr=(satu dua tiga empat) $ for angka in ${arr[@]}; do echo \u0026#34;Putaran ke-$angka\u0026#34;; done Putaran ke-satu Putaran ke-dua Putaran ke-tiga Putaran ke-empat # Associative array $ declare -A arr=([nama]=Alan [kota]=Surabaya [asal]=Jakarta) $ for key in ${!arr[@]}; do echo \u0026#34;Data $key=\u0026gt; ${arr[$key]}\u0026#34;; done Data nama =\u0026gt; Alan Data kota =\u0026gt; Surabaya Data asal =\u0026gt; Jakarta Menambah isi array Cara menambah isi array adalah seperti berikut:\n$ array+=(empat lima) $ echo \u0026#34;${array[@]}\u0026#34; satu dua tiga empat lima # Untuk array asosiatif juga sama $ array+=([key]=value [key2]=value2) Mengubah string menjadi array $ var=\u0026#34;satu dua tiga empat lima\u0026#34; $ array=( $var ) # atau $ declare -a array \u0026lt;\u0026lt;\u0026lt; $var Penjelasan mengenai \u0026lt;\u0026lt;\u0026lt; ada pada artikel mendatang, insyaAllah.\nKasus penggunaan array Pada sebuah script, menentukan sekumpulan options dari suatu command tertentu. Misalnya, script tersebut menggunakan rsync dan ada sekumpulan options dan flag yang sudah ditentukan untuk setiap panggilannya.\n#!/usr/bin/env bash  rsync_options=(--archive --append --bwlimit=512k --progress ...) rsync() { rsync ${rsync_options[@]} .... }  Referensi:\n https://www.geeksforgeeks.org/bash-script-define-bash-variables-and-its-types https://www.shell-tips.com/bash/math-arithmetic-calculation  Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-variabel/","summary":"Pada artikel ini, saya akan menjelaskan bagaimana cara membuat variabel, array, dan lain-lain yang berkaitan, pada shell Bash.\nSeperti yang sudah pernah dibahas pada artikel Belajar Bash Scripting lain, bahwa tentunya Bash Scripting yang dibahas ini tidaklah POSIX-compliant atau istilahnya Bashism.\nAturan penamaan Dalam membuat variabel atau array, ketentuan dalam pemberian nama adalah sebagai berikut:\n Tidak diawali dengan angka. Tidak diawali atau mengandung tanda pentung, tanda @, tanda pagar #.","title":"Belajar Bash Scripting: Variabel"},{"content":"Pada artikel ini saya akan menjelaskan mengenai bagaimana cara melakukan macam-macam kondisional pada Bash scripting. Dan karena ini adalah seri khusus shell Bash, maka tentunya tidak POSIX-compliant.\nKondisional IF Struktur dasar Struktur dasar kondisional if dalam Bash scripting hampir sama dengan keumuman bahasa pemrograman, yaitu seperti dibawah ini:\nif kondisi; then command command ... fi # atau if kondisi then command command ... fi Kondisi yang disebutkan diatas bisa berupa ekspresi perbandingan seperti contoh berikut:\nif [[ $var == xyz ]]; then command command fi # atau if test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34;; then command command fi Atau, bisa berupa command tertentu seperti:\n# Jika command1 sukses maka jalankan command2 dan seterusnya if command1; then command2 command3 ... fi # Contoh # Jika variabel $string mengandung substring xyz, maka jalankan command1 if grep -q \u0026#39;xyz\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$string\u0026#34;; then command1 fi Cara kerja Kondisional if akan menjalankan command di dalam blok jika kondisi yang diujikan memiliki exit status nol. Kedua contoh diatas ( sintaks [[ ... ]] atau test dan grep -q ) sebenarnya sama saja. Dalam artian bahwa sintaks [[ ... ]] sesungguhnya adalah command biasa yang bisa dijalankan diluar blok if. Bisa dicoba sendiri pada sesi shell seperti dibawah ini:\n[[ $var == \u0026#34;xyz\u0026#34; ]] \u0026amp;\u0026amp; echo true test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34; \u0026amp;\u0026amp; echo true Maka, jika variabel $var sama dengan string xyz, maka terminal akan mengeluarkan output \u0026ldquo;true\u0026rdquo;\nannahri@asus-zorin:/tmp$ var=xyz annahri@asus-zorin:/tmp$ [[ $var == \u0026#34;xyz\u0026#34; ]] \u0026amp;\u0026amp; echo true true annahri@asus-zorin:/tmp$ test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34; \u0026amp;\u0026amp; echo true true Ekspresi kondisional / Conditional expression Salah satu contoh ekspresi kondisional adalah seperti yang sudah dijelaskan sebelumnya, yaitu [[ $var == \u0026quot;xyz\u0026quot; ]] yang itu merupakan bentuk dari operator string.\nDisini saya hanya akan menjelaskan beberapa contoh ekspresi yang sering digunakan. Untuk lebih lengkapnya, bisa dibaca sendiri via command help test.\nannahri@asus-zorin:/tmp$ help test test: test [expr] Evaluate conditional expression. Exits with a status of 0 (true) or 1 (false) depending on the evaluation of EXPR. Expressions may be unary or binary. Unary expressions are often used to examine the status of a file. There are string operators and numeric comparison operators as well. ............. Operator file Operator file berfungsi untuk mencari tahu status suatu file. Apakah file tersebut ada, apakah file tersebut adalah suatu direktori, dan lain-lain.\n# Jika $file adalah file reguler if [[ -f $file ]]; then command fi # Jika $file adalah direktori if [[ -d $file ]]; then command fi # atau if test -d \u0026#34;$file\u0026#34;; then command fi Operator string Digunakan untuk melakukan perbandingan suatu variabel terhadap variabel lain atau string literal. Seperti yang sudah dijelaskan pada contoh awal misalnya.\nif [[ $string == \u0026#34;asdf\u0026#34; ]]; then command fi # atau negasinya if [[ $string != \u0026#34;asdf\u0026#34; ]]; then command fi # Jika $string kosong alias unset if [[ -z $string ]]; then command fi # Jika $string tidak kosong alias memiliki nilai if [[ -n $string ]]; then command fi Operator aritmatik Sesuai dengan judulnya, maka operator ini berfungsi untuk melakukan perbandingan aritmatis.\n# Jika $var sama dengan 10 if [[ $var -eq 10 ]]; then command fi # Jika $var tidak sama dengan 10 if [[ $var -ne 10 ]]; then command fi # Jika $var lebih besar dari 10 if [[ $var -gt 10 ]]; then command fi # Jika $var lebih besar atau sama dengan 10 if [[ $var -ge 10 ]]; then command fi # Jika $var lebih kecil dari 10 if [[ $var -lt 10 ]]; then command fi # Jika $var lebih kecil atau sama dengan 10 if [[ $var -le 10 ]]; then command fi Kondisi ganda (Operator AND dan OR) Melakukan evaluasi lebih dari satu kondisi dapat dilakukan dengan operator \u0026amp;\u0026amp; (AND) dan operator || (OR). Contoh penggunaannya adalah sebagai berikut:\n# Jika $val lebih besar dari 10 dan lebih kecil dari 20 if [[ $val -gt 10 \u0026amp;\u0026amp; $val -lt 20 ]]; then command fi # Jika $string tidak kosong dan $string tidak bernilai \u0026#34;xyz\u0026#34; if [[ -n $string \u0026amp;\u0026amp; $string != \u0026#34;xyz\u0026#34; ]]; then command fi # Jika $string tidak kosong atau $val lebih dari nol if [[ -n $string || $val -lt 0 ]]; then command fi Tidak terbatas hanya pada perbandingan variabel, namun operator AND dan OR juga bisa digunakan untuk mengevaluasi 2 command atau lebih.\nBiasanya ini digunakan untuk melakukan perintah yang memerlukan prekondisi dari perintah lain. Seperti memastikan suatu file berhasil dibuat terlebih dahulu sebelum melakukan command setelahnya.\n# Jika path /a/b/c berhasil dibuat dan jika file /a/b/c/d berhasil dibuat if mkdir -p /a/b/c \u0026amp;\u0026amp; touch /a/b/c/d; then command fi Negasi Untuk melakukan evaluasi yang sebaliknya, maka cukup untuk menambahkan sintaks ! sebelum memulai ekspresi atau sebelum [[ ... ]]. Contoh:\n# Jika $file tidak ada, alias kebalikan dari `-f` if [[ ! -f $file ]]; then command fi Beda penempatan operator negasi, juga berbeda pula dampaknya. Jika negasi ditaruh sebelum ekspresi, maka tiap-tiap ekspresi yang berada di konteks yang sama (berada pada satu kurung siku [[ ... ]]) bisa diberlakukan negasi masing-masing. Namun, jika tanda negasi ditaruh diluar seperti ! [[ ... ]] maka negasi diberlakukan setelah seluruh ekspresi yang ada didalamnya dievaluasi.\n# Masing-masing if [[ ! -f $file || ! -d $dir ]]; then command fi # Keseluruhan if ! [[ -z $string || -f $file ]]; then command fi IF berlapis/nested Kondisional if tentu saja bisa dilakukan secara berlapis alias nested.\nif konsisi 1; then command if kondisi 2; then command ... fi fi Bentuk IF ELSE Kondisional IF ELSE jika ekspresi yang dievaluasi tidak terpenuhi maka ELSE akan dijalankan\n# Jika kondisi 1 terpenuhi maka command1 akan dijalankan, jika tidak maka command2 yang akan dijalankan if kondisi 1; then command1 else command2 fi bentuk IF ELSE IF Kondisional IF ELSE IF merupakan bentuk evaluasi ekspresi yang berkelanjutan tetapi perintah-perintah yang ada di dalam kondisi tersebut yang akan dijalankan, alias tidak akan menjalankan 2 kondisi secara bersamaan.\n# Jika kondisi 1 terpenuhi maka command1 dijalankan, jika tidak,  # maka jika kondisi 2 terpenuhi, maka command2 akan dijalankan, namun jika tidak # maka jika kondisi 3 terpenuhi maka command3 akan dijalankan # tetapi jika seluruh kondisi tidak terpenuhi, maka command4 akan dijalankan if kondisi 1; then command1 elif kondisi 2; then command2 elif kondisi 3; then command3 else command4 fi Pada skenario diatas, jika variabel yang dievaluasi adalah variabel yang sama dan hendak mengevaluasi atas nilai-nilai tertentu, maka kondisional CASE-lah yang lebih cocok untuk digunakan. Contohnya sebagai berikut:\nif [[ $string == \u0026#34;a\u0026#34; ]]; then command1 elif [[ $string == \u0026#34;b\u0026#34; ]]; then command2 elif [[ $string == \u0026#34;c\u0026#34; ]]; then command3 . . . elif [[ $string == \u0026#34;z\u0026#34; ]]; then commandX else commandZ fi Bisa dilihat pada contoh diatas bahwa akan banyak pengulangan yang sebetulnya tidak perlu jika menggunakan kondisional CASE.\nKondisional CASE Kondisional CASE digunakan untuk melakukan evaluasi terhadap suatu variabel atau output command tertentu seperti pada contoh sebelumnya. Evaluasi yang dilakukan adalah ekspresi apakah variabel tersebut bernilai sekian atau sekian.\nStruktur dasar Kondisional CASE bisa memiliki beberapa bentuk/model dan merupakan preferensi masing-masing individu, tidak ada benar/salah.\nTetapi pada dasarnya, kondisional CASE diawali dengan case VARIABEL in kemudian diikuti dengan kondisi-kondisi. Tiap kondisi dibuka dengan PATTERN) (perhatikan tanda tutup kurung di akhir) dan ditutup dengan tanda ;;. Dan diakhiri dengan esac.\nBentuk yang umum adalah seperti ini:\n# Jika $string bernilai a, maka command1 dijalankan # Jika $string bernilai b, maka command2 dijalankan # Jika $string bernilai c, maka command3 dijalankan # namun jika tidak seluruhnya, maka commandZ akan dijalankan case \u0026#34;$string\u0026#34; in a) command1 ;; b) command2 ;; c) command3 ;; *) commandZ ;; esac Ada juga yang suka menulis blok CASE seperti ini, jika command untuk tiap kondisi tidaklah panjang.\ncase \u0026#34;$string\u0026#34; in a) command1 ;; b) command2 ;; c) command3 ;; *) commandZ ;; esac Operator OR Satu kondisi dalam CASE bisa diberi operator OR, contoh:\ncase \u0026#34;$string\u0026#34; in a|b) command1 ;; c|d) command2 ;; *) commandZ ;; esac Operator Wildcard * Operator wildcard * digunakan untuk mewakili satu atau lebih karakter. Contoh:\ncase \u0026#34;$string\u0026#34; in # Jika diawali dengan a a*) command1 ;; # Jika diawali dengan b dan diakhiri dengan c b*c) command3 ;; # Jika diakhiri dengan z *z) command4 ;; # Jika seluruh pattern tidak cocok *) commandZ ;; esac Perlu diperhatikan bahwa penempatan kondisi CASE sangat penting. Jika suatu kondisi/pattern yang bersifat lebih umum diletakkan lebih awal daripada yang lebih khusus, maka kondisi yang lebih khusus tersebut tidak akan pernah terevaluasi. Contoh:\n# Pola a*z sudah terwakili dengan pola sebelumnya (a*) # sehingga tidak akan terevaluasi. case \u0026#34;$string\u0026#34; in a*) command1 ;; a*z) command2 ;; esac  Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-conditional/","summary":"Pada artikel ini saya akan menjelaskan mengenai bagaimana cara melakukan macam-macam kondisional pada Bash scripting. Dan karena ini adalah seri khusus shell Bash, maka tentunya tidak POSIX-compliant.\nKondisional IF Struktur dasar Struktur dasar kondisional if dalam Bash scripting hampir sama dengan keumuman bahasa pemrograman, yaitu seperti dibawah ini:\nif kondisi; then command command ... fi # atau if kondisi then command command ... fi Kondisi yang disebutkan diatas bisa berupa ekspresi perbandingan seperti contoh berikut:","title":"Belajar Bash Scripting: Conditional"},{"content":"Sekedar dokumentasi dari permasalahan yang pernah saya jumpai. Terkadang dari sisi aplikasi tidak siap untuk dipublikasi secara HTTPS karena di dalam source code-nya masih ter-hardcoded beberapa resource eksternal menggunakan protokol HTTP.\nHal ini membuat kebanyakan web browser mengeluh dan enggan untuk memuat resource yang dipanggil dari protokol HTTP tadi.\nMaka solusinya ada 2:\n Edit source code-nya, ganti semua kode yang memanggil resource dari HTTP menjadi HTTPS. Dari sisi Reverse-Proxy, tinggal tambahkan header berikut:  add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; Kali ini saya akan membahas solusi untuk Reverse-Proxy Nginx\nContoh konfigurasi server block dan penempatan header :\nserver { listen 443 ssl http2; server_name namawebsite.tld; root /var/www/public_html; ... konfigurasi ssl ... add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; \u0026lt;-- Taruh disini, di dalam server block dan diluar block location location / { ... konfigurasi ... } } Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/jurnal-nginx-reverse-proxy-mixed-content/","summary":"Sekedar dokumentasi dari permasalahan yang pernah saya jumpai. Terkadang dari sisi aplikasi tidak siap untuk dipublikasi secara HTTPS karena di dalam source code-nya masih ter-hardcoded beberapa resource eksternal menggunakan protokol HTTP.\nHal ini membuat kebanyakan web browser mengeluh dan enggan untuk memuat resource yang dipanggil dari protokol HTTP tadi.\nMaka solusinya ada 2:\n Edit source code-nya, ganti semua kode yang memanggil resource dari HTTP menjadi HTTPS. Dari sisi Reverse-Proxy, tinggal tambahkan header berikut:  add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; Kali ini saya akan membahas solusi untuk Reverse-Proxy Nginx","title":"Jurnal: Membenahi kendala mixed-content pada Nginx Reverse-Proxy"},{"content":"Saya akan menjelaskan beberapa tips dan trik dalam menggunakan shell bash yang biasa saya gunakan sehari-hari.\nReverse Search Sebagian orang biasa menggunakan history untuk melihat/mencari command-command sebelumnya yang sudah pernah diinputkan. Atau bahkan menggunakan arrow key atas untuk mencari command yang diinginkan.\nSebenarnya hampir kebanyakan shell memiliki fitur reverse search. Sesuai namanya, fitur ini bisa melakukan pencarian terhadap command yang sebelumya pernah diinputkan.\nBagaimana caranya? Cukup menekan CTRL+Rpada terminal. Dan ketikkan kata kunci untuk command yang sedang dicari.\n(reverse-i-search)`apt\u0026#39;: sudo apt install hugo ^ ^ | |- history terakhir yang paling relevan |- keyword Sintaks Spesial !!, !$ dan !n Sintaks !! Pada bash shell (atau shell yang lain juga, mungkin) menrujuk kepada command terakhir yang diinputkan.\nJadi, jika sebelumnya kita menginputkan, misal, perintah echo abc. Lalu pada input berikutnya jika kita memasukkan !! maka, shell akan mengeksekusi kembali perintah echo abc.\nuser@host:~$ echo abc abc user@host:~$ !! echo abc \u0026lt;--- terminal tidak benar-benar mengeluarkan output ini, hanya sebagai penjelasan ekspansi shell saja abc Ini sangat berguna ketika kita lupa hendak menambahkan sudo pada suatu command yang panjang. Maka, pada input berikutnya, kita tinggal ketikkan sudo !! tanpa perlu mengetik ulang command sebelumnya.\nuser@host:~$ apt install -y package1 package2 package3 package4 package5 E: Could not open lock file /var/lib/dpkg/lock-frontend - open (13: Permission denied) E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), are you root? user@host:~$ sudo !! sudo apt install -y package1 package2 package3 package4 package5 ... Sintaks !$ Sintaks ini merujuk pada positional argument pada command terakhir. Sama seperti contoh sebelumnya, jika echo abc maka ekspansi dari !$ adalah abc.\nKasus penggunaan sintaks ini biasanya saat melakukan editing file. Seperti di bawah ini:\nuser@host:~$ cat /path/panjang/menuju/file isi file user@host:~$ vim !$ vim /path/panjang/menuju/file ... Jadi tidak perlu lagi mengetik ulang path panjang file yang dituju, tapi cukup gunakan sintaks !$ saja.\nSintaks !n Huruf n merujuk kepada angka pada history shell. Jika kita menjalankan perintah history maka tiap-tiap baris history terdapat angka disebelahnya (kecual jika konfigurasi untuk history sudah tidak default). Nah, dengan menggunakan !n maka shell akan mengulangi command yang sama sesuai dengan nomor yang tertera.\nContoh:\nuser@host:~$ history 1 ll 2 ls 3 lsblk 4 history user@host:~$ !1 ll total 20 drwxr-xr-x 1 user user 110 Nov 5 07:23 ./ drwxr-xr-x 1 root root 42 Nov 5 07:22 ../ -rw-r--r-- 1 user user 220 Nov 5 07:22 .bash_logout -rw-r--r-- 1 user user 3771 Nov 5 07:22 .bashrc drwx------ 1 user user 0 Nov 5 07:23 .cache/ drwxr-xr-x 1 user user 40 Nov 5 07:22 .config/ -rw-r--r-- 1 user user 5 Nov 5 07:22 .hidden -rw-r--r-- 1 user user 87 Nov 5 07:22 .inputrc -rw-r--r-- 1 user user 807 Nov 5 07:22 .profile Pintasan Clear Screen clear Command clear digunakan untuk membersihkan sesi layar shell. Agar lebih cepat, cukup tekan kombinasi tombol CTRL+L.\n Bersambung, insyaAllah\n","permalink":"https://blog.annahri.com/posts/trik-bash-shell-1/","summary":"Saya akan menjelaskan beberapa tips dan trik dalam menggunakan shell bash yang biasa saya gunakan sehari-hari.\nReverse Search Sebagian orang biasa menggunakan history untuk melihat/mencari command-command sebelumnya yang sudah pernah diinputkan. Atau bahkan menggunakan arrow key atas untuk mencari command yang diinginkan.\nSebenarnya hampir kebanyakan shell memiliki fitur reverse search. Sesuai namanya, fitur ini bisa melakukan pencarian terhadap command yang sebelumya pernah diinputkan.\nBagaimana caranya? Cukup menekan CTRL+Rpada terminal. Dan ketikkan kata kunci untuk command yang sedang dicari.","title":"Trik Bash Shell #1"},{"content":"Saya akan menjelaskan cara mudah untuk resize disk suatu VM dengan konfigurasi LVM. Asumsinya, disk sudah diextend dari sisi HVnya (PVE, ESXi, dll).\nPastikan penambahan space sudah terdeteksi dari VM melalui dmesg dan Anda akan mendapati informasi seperti ini:\n[262733.527587] sd 0:0:2:0: [abc] 4096-byte physical blocks [262733.528263] abc: detected capacity change from 214748364800 to 429496729600 Kalau ternyata belum terdeteksi, bisa dicoba untuk menjalankan perintah ini\necho 1 \u0026gt; /sys/class/block/\u0026lt;disk\u0026gt;/device/rescan Lalu coba cek kembali di dmesg. Kalau sudah muncul bisa langsung jalankan perintah berikut:\ngrowpart /dev/\u0026lt;disk\u0026gt; \u0026lt;no-partisi\u0026gt; # contoh `growpart /dev/sda 1` pvresize /dev/\u0026lt;partisi\u0026gt; # contoh `pvresize /dev/sda1` lvresize --extents +100%FREE --resizefs /dev/xxx/yyy # Value xxx yyy merujuk pada logical volume path Khusus untuk growpart jika tidak tersedia pada sistem Anda, maka bisa Anda gunakan parted\nparted /dev/\u0026lt;disk\u0026gt; (parted) resizepart \u0026lt;no-partisi\u0026gt; 100% (parted) quit Selesai. Semoga bermanfaat, insyaAllah\n","permalink":"https://blog.annahri.com/posts/jurnal-cara-extend-vm-disk-lvm/","summary":"Saya akan menjelaskan cara mudah untuk resize disk suatu VM dengan konfigurasi LVM. Asumsinya, disk sudah diextend dari sisi HVnya (PVE, ESXi, dll).\nPastikan penambahan space sudah terdeteksi dari VM melalui dmesg dan Anda akan mendapati informasi seperti ini:\n[262733.527587] sd 0:0:2:0: [abc] 4096-byte physical blocks [262733.528263] abc: detected capacity change from 214748364800 to 429496729600 Kalau ternyata belum terdeteksi, bisa dicoba untuk menjalankan perintah ini\necho 1 \u0026gt; /sys/class/block/\u0026lt;disk\u0026gt;/device/rescan Lalu coba cek kembali di dmesg.","title":"Jurnal: Cara Extend VM Disk untuk LVM"},{"content":"LEMP stack adalah software stack yang terdiri dari (L)inux, (E)gin-x alias Nginx, (M)ysql atau Mariadb, dan (P)HP.\nDi sini, saya akan menjelaskan bagaimana cara instalasi LEMP stack pada Ubuntu 20.04. Untuk OS berbasis RPM menyusul.\nKonfigurasi Awal Pastikan repositori Anda sudah pada kondisi terbaru dan package pada sistem anda terupgrade.\n$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Jika menggunakan firewall, pastikan port 80 (HTTP) dan 443 (HTTPS) terbuka. Kalau anda menggunakan ufw maka perintahnya adalah:\n$ sudo ufw allow proto tcp from any to any port 80,443 Gunakan perintah dibawah ini kalau Anda menggunakan iptables:\n$ sudo iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT # agar rule diatas menjadi \u0026#39;permanen\u0026#39; $ iptables-save | sudo tee /etc/iptables/rules.v4 Instalasi Stack Selanjutnya instal nginx, mariadb, dan php-fpm :\n$ sudo apt install -y \\  nginx \\  mariadb-server mariadb-common \\  php7.4-fpm php7.4 php7.4-common php7.4-mysql Pastikan semua service berjalan dengan baik :\n$ sudo systemctl status nginx $ sudo systemctl status mariadb $ sudo systemctl status php7.4-fpm Jika belum berjalan, maka jalankan service-service tersebut dengan perintah:\n$ sudo systemctl enable nginx --now $ sudo systemctl enable mariadb --now $ sudo systemctl enable php7.4-fpm --now Kemudian cek juga apakah port 80 sudah listen atau belum.\n$ sudo ss -tulpn | grep \u0026#39;:80\u0026#39; Untuk port 443 masih belum. Karena setelah instalasi baru, secara asal port 80 yang listen.\nTes Web Server Untuk itu, silahkan coba buka browser menggunakan alamat IP server. Atau juga bisa menggunakan domain. Jika memang sudah diatur A recordnya.\nAtau, pengecekan bisa dilakukan dengan menggunakan curl :\n$ curl localhost \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tes Halaman PHP Buat file php dengan isi berikut, simpan di /var/www/html/phpinfo.php:\n\u0026lt;?php phpinfo(); ?\u0026gt;Kemudian pada browser / curl, silahkan coba akses http://IP SERVER/phpinfo.php:\n$ curl localhost/phpinfo.php \u0026lt;?php phpinfo(); ?\u0026gt; Kok tidak berhasil? Ya, karena nginx belum diatur untuk memproses halaman php.\nEdit file /etc/nginx/sites-available/default.conf kemudian cari baris berikut, dan hilangkan pagar-pagar didepannya (alias uncomment) :\nlocation ~ \\.php$ { include snippets/fastcgi-php.conf; # # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; } Sederhananya, blok diatas menginstrusikan nginx untuk memproses seluruh file yang berakhiran .php kepada php-fpm. Bisa melalui socket unix (unix:/path/to/socket.sock) atau socket tcp (IP:port).\nSetelah itu, reload konfigurasi nginx sudo nginx -s reload dan tes kembali menggunakan curl atau browser.\n$ curl localhost/phpinfo.php Jika menghasilkan halaman info php, maka konfigurasi sudah benar.\nKonfigurasi dan Tes Konektivitas Database Biasakan untuk selalu menjalankan mysql_secure_installation setiap kali menginstall mariadb-server atau mysql-server. Karena sesuai dengan namanya, perintah tersebut memastikan instalasi mysql itu aman alias secure.\n$ sudo mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we\u0026#39;ll need the current password for the root user. If you\u0026#39;ve just installed MariaDB, and you haven\u0026#39;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] Y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y Y ... Success! Normally, root should only be allowed to connect from \u0026#39;localhost\u0026#39;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] Y ... Success! By default, MariaDB comes with a database named \u0026#39;test\u0026#39; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y ... Success! Cleaning up... All done! If you\u0026#39;ve completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! Jawab setiap promptnya dengan Y.\nKemudian kita buat satu database percobaan dan satu database user.\n$ sudo mysql CREATEDATABASEtesdb;CREATEUSERdbuser@localhostIDENTIFIEDBY\u0026#39;password\u0026#39;;GRANTALLPRIVILEGESONtesdb.*TOdbuser@localhost;FLUSHPRIVILEGES;Buat satu file untuk uji coba konek php ke database. Simpan di /var/www/html/tesdb.php\n\u0026lt;?php $con = mysqli_connect(\u0026#34;localhost\u0026#34;,\u0026#34;dbuser\u0026#34;,\u0026#34;password\u0026#34;,\u0026#34;tesdb\u0026#34;); if (mysqli_connect_errno()) { echo \u0026#34;Failed to connect to MySQL: \u0026#34; . mysqli_connect_error(); exit(); } else { echo \u0026#34;Koneksi Database Berhasil.\u0026#34;; } ?\u0026gt;Tes kembali menggunakan browser atau curl, buka http://IP SERVER/testdb.php\n$ curl localhost/testdb.php Koneksi Database Berhasil. Selesai!\n Kesimpulan Begitu mudahnya untuk melakukan instalasi LEMP stack pada Ubuntu 20.04. Cukup menginstal nginx + mysql/mariadb + php-fpm, dan sedikit konfigurasi pada nginx.\nTentunya akan memerlukan konfigurasi lebih lanjut jika hendak menginstal webapp semacam wordpress, dan semisalnya.\nSemoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/lemp-stack-ubuntu20-04-focal/","summary":"LEMP stack adalah software stack yang terdiri dari (L)inux, (E)gin-x alias Nginx, (M)ysql atau Mariadb, dan (P)HP.\nDi sini, saya akan menjelaskan bagaimana cara instalasi LEMP stack pada Ubuntu 20.04. Untuk OS berbasis RPM menyusul.\nKonfigurasi Awal Pastikan repositori Anda sudah pada kondisi terbaru dan package pada sistem anda terupgrade.\n$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Jika menggunakan firewall, pastikan port 80 (HTTP) dan 443 (HTTPS) terbuka. Kalau anda menggunakan ufw maka perintahnya adalah:","title":"Instalasi LEMP Stack (Linux, Nginx, MariaDB, PHP) pada Ubuntu 20.04"}]