[{"content":"Ini adalah artikel ringkas yang membahas tentang cara untuk mencari tahu seluruh konfigurasi filter yang diatur oleh tiap akun email.\nPada dasarnya, perintah yang digunakan adalah:\nzmprov -l ga \u0026lt;nama akun\u0026gt; zimbraMailSieveScript Contoh output:\n# name user1@example.com zimbraMailSieveScript: require [\u0026#34;fileinto\u0026#34;, \u0026#34;copy\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;tag\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;variables\u0026#34;, \u0026#34;log\u0026#34;, \u0026#34;enotify\u0026#34;, \u0026#34;envelope\u0026#34;, \u0026#34;body\u0026#34;, \u0026#34;ereject\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;relational\u0026#34;, \u0026#34;comparator-i;ascii- numeric\u0026#34;]; # forward if anyof (address :all :contains :comparator \u0026#34;i;ascii-casemap\u0026#34; [\u0026#34;to\u0026#34;] \u0026#34;user1@example.com\u0026#34;) { redirect \u0026#34;user2@example.com\u0026#34;; stop; } Sehingga, untuk meng-query keseluruhan akun, bisa menggunakan loop atau xargs:\nzmprov -l gaa | xargs -n1 -I zmprov -l ga {} zimbraMailSieveScript # atau  for account in $(zmprov -l gaa); do echo \u0026#34;$account\u0026#34; zmprov -l ga \u0026#34;$account\u0026#34; zimbraMailSieveScript done # atau zmprov -l gaa | while read account; do echo \u0026#34;$account\u0026#34; zmprov -l ga \u0026#34;$account\u0026#34; zimbraMailSieveScript done # atau while read account; do echo \u0026#34;$account\u0026#34; zmprov -l ga \u0026#34;$account\u0026#34; zimbraMailSieveScript done \u0026lt; \u0026lt;(zmprov -l gaa) Semoga bermanfaat, barakallahufiikum.\n Referensi: Steps to get filters of all accounts\n","permalink":"https://blog.annahri.com/posts/jurnal-zimbra-mencari-tahu-konfigurasi-filter-untuk-semua-akun/","summary":"Ini adalah artikel ringkas yang membahas tentang cara untuk mencari tahu seluruh konfigurasi filter yang diatur oleh tiap akun email.\nPada dasarnya, perintah yang digunakan adalah:\nzmprov -l ga \u0026lt;nama akun\u0026gt; zimbraMailSieveScript Contoh output:\n# name user1@example.com zimbraMailSieveScript: require [\u0026#34;fileinto\u0026#34;, \u0026#34;copy\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;tag\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;variables\u0026#34;, \u0026#34;log\u0026#34;, \u0026#34;enotify\u0026#34;, \u0026#34;envelope\u0026#34;, \u0026#34;body\u0026#34;, \u0026#34;ereject\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;relational\u0026#34;, \u0026#34;comparator-i;ascii- numeric\u0026#34;]; # forward if anyof (address :all :contains :comparator \u0026#34;i;ascii-casemap\u0026#34; [\u0026#34;to\u0026#34;] \u0026#34;user1@example.com\u0026#34;) { redirect \u0026#34;user2@example.com\u0026#34;; stop; } Sehingga, untuk meng-query keseluruhan akun, bisa menggunakan loop atau xargs:","title":"Jurnal: Zimbra - Mencari Tahu Konfigurasi Filter Untuk Semua Akun"},{"content":"Artikel ini akan menjelaskan mengenai bagaimana cara untuk melakukan LOOP alias menjalankan sekumpulan command secara berulang-ulang dengan kondisi tertentu.\nFOR loop FOR loop pada shell Bash sifatnya sama seperti foreach pada keumuman bahasa pemrograman. Yaitu melakukan perulangan tanpa adanya counter, alias suatu perulangan tidaklah diketahui ke-berapa perulangan tersebut sedang terjadi. Atau sederhananya tidak ada indeks pada setiap perulangan.\nNamun dengan pengecualian jika FOR loop tersebut dideklarasikan menggunakan indeks. Akan tiba contohnya pada penjelasan di bawah.\nStruktur dasar Variabel $var dibawah ini adalah variabel yang berisi string-string yang dipisahkan dengan spasi.\n$ var=\u0026#34;a b c d\u0026#34; $ for VARIABEL in $var; do echo \u0026#34;Huruf $VARIABEL\u0026#34; done Huruf a Huruf b Huruf c Huruf d Sebenarnya, sintaks in VARIABEL adalah opsional. Jika sintaks tersebut tidak disebutkan, maka Bash akan mengambil dari Positional Argument.\n$ set -- 1 2 3 4 $ for angka; do echo \u0026#34;Angka ke-$angka\u0026#34; done Angka ke-1 Angka ke-2 Angka ke-3 Angka ke-4 Pada bagian in juga bisa diberikan suatu command yang outputnya akan digunakan untuk looping.\n$ for x in $(seq 10); do echo \u0026#34;Urutan ke $x\u0026#34; done Urutan ke 1 Urutan ke 2 ... Urutan ke 10 Model bahasa C (C-Style FOR loop) C-style loop sesuai dengan namanya, yaitu model FOR loop menggunakan model bahasa pemrograman C.\n$ for ((i = 0; i \u0026lt; 10; i++)); do echo \u0026#34;Angka $i\u0026#34; done Angka 0 Angka 1 Angka 2 ... Angka 9 WHILE loop Sama seperti keumuman bahasa pemrograman, WHILE loop ini akan terus diulang-ulang selama kondisi yang diujikan masih benar.\nWHILE loop ini memberikan fleksibilitas yang lebih daripada FOR loop. Ketika FOR loop hanya terbatas pada tiap yang argumen diberikan, WHILE loop bisa digunakan lebih dari itu.\nStruktur dasar Agak mirip secara struktur, yaitu dimulai dari while kondisi; do ...; done. Setiap loop pada bash, pasti ada sintaks do .. done.\nwhile [[ $x -lt 10 ]]; do command ... ((x++)) done Looping terus-menerus Karena sifat WHILE loop ini yang akan terus melakukan perulangan ketika kondisi yang diujikan bernilai benar, maka jika ia diberikan sintaks yang selalu bernilai benar seperti true misalnya, maka akan dihasilkan infinite loop.\nwhile true; do command ... if kondisi; then break fi done # atau while :; do command ... if kondisi; then break fi done Mengulang command terus-menerus Sebagaimana yang telah dicontohkan pada bagian sebelumnya (looping terus-menerus), sebenarnya sintaks true dan : merupakan sebuah command yang valid jika dijalankan pada shell secara langsung. Sehingga, WHILE loop bisa diletakkan padanya suatu command yang memiliki exit status. Jika exit status command tersebut adalah non-zero alias tidak bermasalah, maka loop akan berlanjut.\nwhile sleep 1; do command command done # atau while ssh -T HOST uptime; do sleep 1 done Membaca file, variabel atau output command dengan WHILE loop WHILE loop bisa dimanfaatkan untuk membaca baris tiap baris dari sebuah file atau output suatu command atau pipeline. Ini berguna jika kita hendak memproses tiap baris pada output tersebut.\nLoop dari pipe Melakukan piping semacam dibawah ini bisa dilakukan selama didalam loop tidak ada proses penyematan variabel. Karena, pipeline berlangsung didalam subshell sehingga, variabel yang sama, yang dipanggil dari dalam loop ini, adalah variabel yang berbeda. Namun, jika aktifitas loop tidak ada kegiatan mengisi isi variabel (yang sudah dideklarasi sebelum pipe ini) dan sebagainya, maka loop ini bisa dipakai.\nfind /dir -type f -name \u0026#39;pattern\u0026#39; | while read line; do file=$(basename \u0026#34;$line\u0026#34;) new_name=\u0026#34;new-${file}\u0026#34; echo \u0026#34;Renaming $fileto $new_name\u0026#34; mv \u0026#34;$file\u0026#34; \u0026#34;$new_name\u0026#34; done Loop dengan input dari file, variabel atau process substitution Process Substitution memungkinkan kita untuk menginputkan serangkaian command (pipeline).\nDalam kasus loop ini, WHILE mendapat input tidak dari pipe sehingga semua yang terjadi didalamnya, tidak berada di dalam subshell. Yang artinya, semua penyematan variabel di dalam loop, akan benar-benar tersematkan.\nwhile read line; do ... done \u0026lt; file # atau while read line; do ... done \u0026lt;\u0026lt;\u0026lt; \u0026#34;$var\u0026#34; # atau while read line; do ... done \u0026lt; \u0026lt;(command) UNTIL loop UNTIL loop adalah kebalikan dari WHILE loop. Yaitu melakukan perulangan selama kondisi yang diberikan tetap bernilai salah.\nStruktur dasar Sama dengan WHILE loop, cukup menggantinya dengan UNTIL\nuntil kondisi; do command done # misal until [[ $# -eq 0 ]]; do : proses loop done Contoh penggunaan dalam script:\n# Loop akan exit jika input file yang diberikan adalah valid until [[ -f \u0026#34;$file\u0026#34; ]]; do read -p \u0026#34;Masukkan input file \u0026gt; \u0026#34; file done Sintaks break dan continue Sintaks break dan continue tidak terbatas hanya pada WHILE loop saja, tetapi juga bisa digunakan pada UNTIL dan FOR loop juga. Kedua sintaks ini berfungsi untuk mengatur alur suatu loop, baik untuk menghentikan loop (keluar dari loop) atau meloncati suatu iterasi.\nBreak Dalam infinite loop, perlu ada kondisi yang dimana dia akan membuat loop tersebut berhenti. Untuk dapat keluar dari loop, gunakan sintaks break. Contoh untuk ini sudah dijelaskan pada bagian WHILE loop sebelumnya. Atau misal pada kasus script interaktif seperti contoh berikut:\nwhile read -p \u0026#34;Masukkan angka 1-10 \u0026gt; \u0026#34; angka; do if [[ $angka -gt 10 || $angka -lt 1 || $angka =~ [^0-9]+ ]]; then echo \u0026#34;Input tidak valid!\u0026#34; else echo \u0026#34;Angka terpilih: $angka\u0026#34; break fi done Continue Sedangkan jika dalam suatu loop ada sebuah kondisi yang jika kondisi tersebut terpenuhi, maka perputaran saat itu diloncati, maka hal tersebut bisa dilakukan dengan sintaks continue.\nfor ((i = 1; i \u0026lt; 10; i++)); do if ((i % 2 != 0)); then continue fi ... done Loop non-standar Pipeline jika dirangkai sedemikian rupa juga akan bisa melakukan loop. Contohnya adalah gabungan dari seq atau Bash brace expansion yang dipipe kepada xargs seperti contoh berikut ini:\nseq 10 | xargs -n1 -I{} echo \u0026#34;Putaran ke-{}\u0026#34; # atau serupa dengan for i in {1..10}; do echo \u0026#34;Putaran ke-$i\u0026#34; done Mencari bilangan genap dari 1 sampai 100 :\necho {1..100} | xargs -n1 -I{} bash -c \u0026#39;if (( {} % 2 == 0 )); then echo {}; fi\u0026#39;  Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-loop/","summary":"Artikel ini akan menjelaskan mengenai bagaimana cara untuk melakukan LOOP alias menjalankan sekumpulan command secara berulang-ulang dengan kondisi tertentu.\nFOR loop FOR loop pada shell Bash sifatnya sama seperti foreach pada keumuman bahasa pemrograman. Yaitu melakukan perulangan tanpa adanya counter, alias suatu perulangan tidaklah diketahui ke-berapa perulangan tersebut sedang terjadi. Atau sederhananya tidak ada indeks pada setiap perulangan.\nNamun dengan pengecualian jika FOR loop tersebut dideklarasikan menggunakan indeks. Akan tiba contohnya pada penjelasan di bawah.","title":"Belajar Bash Scripting: Loop"},{"content":"Pada artikel ini saya akan memberikan contoh script Bash dan Python yang berfungsi untuk menampilkan jumlah antrian email (mail queue) keluar pada Postfix. Ini berguna sebagai metrics yang bisa digunakan untuk alerting. Baik alerting manual maupun terintegrasi seperti ServerDensity, dan sebagainya.\nDasar Script Komponen utama utama untuk mengetahui mail queue adalah folder dimana queue tersebut singgah untuk sementara waktu. Untuk mengetahuinya, kita bisa memanggil command postconf -h queue_directory yang outputnya akan menunjukkan dimana direktori tersebut.\nContoh struktur dari folder queue tersebut adalah seperti ini:\nroot@postfix-relay-new:/var/spool/postfix# tree -d -L 1 -n . ├── active ├── bounce ├── corrupt ├── defer ├── deferred ├── dev ├── etc ├── flush ├── hold ├── incoming ├── lib ├── maildrop ├── pid ├── private ├── public ├── saved ├── trace └── usr 18 directories Folder-folder yang berisi queue email adalah active, corrupt, defer, deferred, hold dan incoming.\nContoh file queue yang ada pada folder deferred:\nroot@postfix-relay-new:/var/spool/postfix/deferred# find -type f ./E/EAB4426846 ./7/7C31723297 ./B/B2F962B543 ... ./2/28BD526F02 ./8/8B6742C09D ./5/548D72A868 Sehingga dari situ, kita cukup meracik command find sedemikian rupa sehingga command tersebut hanya akan menampilkan file-file queue saja pada direktori yang sudah ditunjuk oleh postconf -h queue_directory. Karena ciri file queue sifatnya seragam, maka bisa kita gunakan Regular Expression dibawah ini:\n[0-9A-F]+ Kemudian, jika sudah dapat outputnya, maka untuk masing-masing kondisi queue (active/defer, dsb) tinggal dihitung ada berapa baris yang pada path -nya terdapat substring active misalnya. Atau defer, dll. Dan ini bisa dilakukan dengan berbagai macam cara. Salah satu diantaranya adalah dengan grep.\ngrep -w -c \u0026#39;active\u0026#39; input # Dimana: # -w mencari kata utuh, bukan substring # -c jumlah temuan Dan selesai, intinya hanya itu saja.\nVersi Bash #1 Idenya adalah dengan menyimpan daftar queue pada suatu file temporer, kemudian untuk setiap state, kita panggil grep count untuk menemukan ada berapa kali keyword state tersebut ditemukan pada file temporer tersebut.\n#!/usr/bin/env bash  readonly queue_dir=$(postconf -h queue_directory) readonly tmp_file=$(mktemp) states=(all active corrupt defer deferred hold incoming) get_count() { printf \u0026#39;%s: %d\\n\u0026#39; \u0026#34;$1\u0026#34; $(egrep -w -c \u0026#34;$2\u0026#34; \u0026#34;$tmp_file\u0026#34;) } main() { find \u0026#34;$queue_dir\u0026#34; -type f -regextype egrep -regex \u0026#39;.*/[0-9A-F]{5,}$\u0026#39; \u0026gt; \u0026#34;$tmp_file\u0026#34; for state in ${states[@]}; do search=\u0026#34;$state\u0026#34; [[ $state = all ]] \u0026amp;\u0026amp; search=\u0026#39;.*\u0026#39; get_count \u0026#34;$state\u0026#34; \u0026#34;$search\u0026#34; done rm -f \u0026#34;$tmp_file\u0026#34; } main Contoh output jika dijalankan:\nroot@postfix-relay-new:~/script# time bash script.sh all: 43 active: 0 corrupt: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.098s user\t0m0.026s sys\t0m0.015s Versi Bash #2 Melakukan loop untuk setiap entri queue yang ditemukan kemudian langsung menghitungnya dan menyimpannya pada array asosiatif. Tetapi ini memerlukan 2 kali loop. Yang pertama untuk menghitung jumlah, yang kedua untuk mengeluarkan output.\n#!/usr/bin/env bash  readonly queue_dir=$(postconf -h queue_directory) declare -A count=([active]=0 [corrupt]=0 [defer]=0 [deferred]=0 [hold]=0 [incoming]=0) total=0 while read line; do state=$(cut -d\u0026#39;/\u0026#39; -f5 \u0026lt;\u0026lt;\u0026lt; \u0026#34;$line\u0026#34;) (( ++count[$state] )) (( ++total )) done \u0026lt; \u0026lt;(find \u0026#34;$queue_dir\u0026#34; -type f -regextype egrep -regex \u0026#39;.*/[0-9A-F]+$\u0026#39;) echo \u0026#34;all: $total\u0026#34; for i in ${!count[@]}; do printf \u0026#39;%s: %d\\n\u0026#39; $i ${count[$i]} done | sort Output:\nroot@postfix-relay-new:~/script# time bash script3.sh all: 43 active: 0 corrupt: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.133s user\t0m0.084s sys\t0m0.052s Versi Bash #3 (dengan AWK) Versi AWK ini merupakan versi paling cepat diantara versi script Bash sebelumnya. Karena shell tidak melakukan loop sama sekali, dan seluruh proses dilakukan oleh awk dalam sekali eksekusi. Sedangkan pada script sebelumnya (#2), setiap iterasi ada eksekusi eksternal tool cut yang berdampak pada durasi eksekusi (meskipun tidak terlalu signifikan).\nIde yang digunakan, sama dengan pada script bash versi kedua.\n#!/usr/bin/env bash  find `postconf -h queue_dir` -type f -regextype egrep -regex \u0026#39;.*/[0-9A-F]{5,}$\u0026#39; \\  | awk -F\u0026#39;/\u0026#39; \u0026#39;BEGIN { count[\u0026#34;active\u0026#34;]=0; count[\u0026#34;corrupt\u0026#34;]=0; count[\u0026#34;defer\u0026#34;]=0; count[\u0026#34;deferred\u0026#34;]=0; count[\u0026#34;hold\u0026#34;]=0; count[\u0026#34;incoming\u0026#34;]=0 } { count[$5]++; total++ } END { print \u0026#34;all:\u0026#34;, total; for (n in count) print n\u0026#34;:\u0026#34;, count[n] | \u0026#34;sort\u0026#34; }\u0026#39; Agar mempermudah memahami sintaks awk panjang tersebut, berikut ini versi baris per baris:\nBEGIN { count[\u0026#34;active\u0026#34;]=0 count[\u0026#34;corrupt\u0026#34;]=0 count[\u0026#34;defer\u0026#34;]=0 count[\u0026#34;deferred\u0026#34;]=0 count[\u0026#34;hold\u0026#34;]=0 count[\u0026#34;incoming\u0026#34;]=0 } { count[$5]++ total++ } END { print \u0026#34;all:\u0026#34;, total for (n in count) print n\u0026#34;:\u0026#34;, count[n] | \u0026#34;sort\u0026#34; } Output:\nroot@postfix-relay-new:~/script# time bash wawk.sh all: 43 active: 0 corrupt: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.083s user\t0m0.011s sys\t0m0.011s Versi Python Script versi Python ini menggunakan ide yang sama pada script bash pertama.\nimport os from subprocess import check_output def get_list(): queue_dir = check_output([\u0026#39;postconf\u0026#39;,\u0026#39;-h\u0026#39;,\u0026#39;queue_directory\u0026#39;]).decode(\u0026#39;utf-8\u0026#39;).rstrip() command_string = \u0026#39;find \u0026#39; + queue_dir + \u0026#39; -type f -regextype egrep -regex .*/[0-9A-F]+$\u0026#39; return check_output(command_string.split()).decode(\u0026#39;utf-8\u0026#39;).rstrip().split(\u0026#39;\\n\u0026#39;) def get_count(string, search, list): n = sum(search in entry for entry in list) print(f\u0026#39;{string}: {n}\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: result = get_list() states = [\u0026#39;all\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;corrupt\u0026#39;, \u0026#39;defer\u0026#39;, \u0026#39;deferred\u0026#39;, \u0026#39;hold\u0026#39;, \u0026#39;incoming\u0026#39;] for state in states: search = state + \u0026#39;/\u0026#39; if state != \u0026#39;all\u0026#39; else \u0026#39;\u0026#39; get_count(state, search, result) Contoh output jika dijalankan:\nroot@postfix-relay-new:~/script# time python3 mqueue.py all: 43 active: 0 corrupted: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.076s user\t0m0.055s sys\t0m0.011s  Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/jurnal-script-rincian-mail-queue-postfix/","summary":"Pada artikel ini saya akan memberikan contoh script Bash dan Python yang berfungsi untuk menampilkan jumlah antrian email (mail queue) keluar pada Postfix. Ini berguna sebagai metrics yang bisa digunakan untuk alerting. Baik alerting manual maupun terintegrasi seperti ServerDensity, dan sebagainya.\nDasar Script Komponen utama utama untuk mengetahui mail queue adalah folder dimana queue tersebut singgah untuk sementara waktu. Untuk mengetahuinya, kita bisa memanggil command postconf -h queue_directory yang outputnya akan menunjukkan dimana direktori tersebut.","title":"Jurnal: Script Rincian Mail Queue Postfix"},{"content":"Pada artikel ini, saya akan menjelaskan bagaimana cara membuat variabel, array, dan lain-lain yang berkaitan, pada shell Bash.\nSeperti yang sudah pernah dibahas pada artikel Belajar Bash Scripting lain, bahwa tentunya Bash Scripting yang dibahas ini tidaklah POSIX-compliant atau istilahnya Bashism.\nAturan penamaan Dalam membuat variabel atau array, ketentuan dalam pemberian nama adalah sebagai berikut:\n Tidak diawali dengan angka. Tidak mengandung tanda pentung, tanda @, tanda pagar # dan asterisk (*). Variabel dengan huruf kapital seluruhnya, dikhususkan untuk variabel internal shell dan varibel environment.  Contoh:\n1variabel # salah !variabel # salah @variabel # salah vari*abel # salah #variabel # salah vari#abel # salah vari!abel # salah vari@abel # salah SHELL # sudah digunakan sebagai environment variable HOSTNAME # sudah digunakan sebagai environment variable REPLY # sudah digunakan dalam BASH internal variable variabel # benar Variabel # benar vAriabel # benar vari_abel # benar _variabel # benar vari4bel # benar variabel1 # benar Variabel Membuat variabel Pada Bash shell, variabel bisa dibuat dengan cara seperti ini:\n# Tanpa petik var=string # Petik var=\u0026#34;string\u0026#34; # Petik tunggal var=\u0026#39;string\u0026#39; Perbedaan mengenai penggunaan tanda petik dan petik tunggal akan dijelaskan nanti.\nPerlu diperhatikan bahwa untuk membuat variabel, tidak boleh ada spasi diantara tanda =, misalnya:\n# Salah var = \u0026#34;string\u0026#34; var= \u0026#34;string\u0026#34; var =\u0026#34;string\u0026#34; Melihat isi variabel Isi variabel bisa dilihat dengan command echo atau printf:\n$ var=\u0026#34;Bismillah\u0026#34; $ echo \u0026#34;$var\u0026#34; Bismillah $ printf \u0026#39;%s\\n\u0026#39; \u0026#34;$var\u0026#34; Bismillah Mengisi variabel dari output suatu command Suatu variabel bisa diisi dengan output dari suatu command tertentu dengan menggunakan 2 cara:\n Menggunakan backticks `\u0026hellip;` Menggunakan command substitution $(...)  Contoh:\nvar=`uname -r` var=$(uname -r) Cara kedua lebih disarankan karena 1) backticks sudah dianggap telah deprecated (ditinggalkan), 2) command substitution memungkinkan untuk digunakan secara berlapis. Misal:\nvar=$(ls -1 $(pwd)) Menambah isi variabel (append) Menambah isi variabel (yang berupa string) bisa dilakukan seperti membuat variabel tersebut namun tidak sekedar dengan tanda = saja, tetapi dengan +=, contoh:\n$ var=Hello $ echo \u0026#34;$var\u0026#34; Hello $ var+=\u0026#34;, World!\u0026#34; $ echo \u0026#34;$var\u0026#34; Hello, World! Kalkulasi aritmatis pada variabel (integer) Membuat variabel berupa hasil kalkulasi 2 bilangan bulat (atau lebih), bisa dilakukan dengan dua tanda kurung $((...))\n$ bil1=5 $ bil2=9 $ hasil=$((bil1 + bil2)) $ echo $hasil 14 $ kali=$((bil1 * bil2)) $ echo $kali 45 Variabel readonly Variabel readonly adalah variabel yang tidak bisa berubah setelah ditetapkan isinya, sama dengan konsep variabel konstan pada keumuman bahasa pemrograman.\n# cara 1 $ readonly var=string # cara 2 $ declare -r var=string $ var=strong bash: var: readonly variable Variabel lokal Variabel lokal adalah variabel yang ruang lingkupnya hanya pada suatu fungsi saja. Ketika dipanggil diluar fungsi tersebut, maka variabel yang dipanggil tersebut adalah variabel yang berbeda.\n$ var=xyz $ fungsi() { local var=abc # atau declare var=abc echo \u0026#34;$var\u0026#34; } $ echo \u0026#34;$var\u0026#34; xyz $ fungsi abc Membuat variabel dengan printf Command printf adalah salah satu tool builtin pada shell Bash. Selain berfungsi seperti echo, printf juga bisa digunakan untuk menetapkan suatu variabel.\n$ printf -v var \u0026#39;%s\\n\u0026#39; string $ echo \u0026#34;$var\u0026#34; string Membuat variabel berdasarkan input pengguna Yang dimaksud disini adalah membuat variabel dengan cara interaktif, yaitu membutuhkan inputan dari pengguna shell. Seperti \u0026ldquo;Siapa namamu?\u0026rdquo;, kemudian pengguna mengisikan namanya.\n$ read -r -p \u0026#34;Siapa namamu? \u0026#34; nama Siapa namamu? Fulan bin Fulan $ echo \u0026#34;Namaku: $nama\u0026#34; Namaku: Fulan bin Fulan Flag -r diatas berfungsi untuk menghindari backslash dari melakukan escaping karakter apapun. Sedangkan -p berfungsi untuk mem-print serangkaian kata yang sudah ditentukan sebelum melakukan read. Ini guna menghemat dari penggunaan echo sebelum read.\nKasus penggunaan tool read ini diantaranya adalah seperti melakukan konfirmasi Yes/No sebelum menjalankan command tertentu; atau membuat script yang interaktif, dan sebagainya.\nArray Diantara shell-shell yang ada, diantaranya ada yang mendukung array dan ada yang tidak. Bash adalah salah satu yang mendukung array. Jenis array yang bisa dibuat pada shell bash adalah Associative Array dan Indexed Array\nArray terindeks (indexed array) Yang dimaksud dengan indexed array adalah array yang tiap anggotanya memiliki nomor indeks masing-masing yang dimulai dari nol (zero indexed). Cara membuatnya adalah seperti berikut:\n# cara 1 array=(satu dua tiga) # cara 2 declare -a array=(satu dua tiga) Array asosiatif (associative array) Associative array, adalah jenis array yang memiliki key dan value. Cara membuat:\n$ declare -A array=([nama]=Fulan [kota]=Surabaya [pendidikan]=S1) $ array[status]=\u0026#34;Lajang\u0026#34; $ array[pekerjaan]=\u0026#34;Swasta\u0026#34; Melihat isi array Untuk melihat seluruh isi array:\nIndexed array $ echo \u0026#34;${array[@]}\u0026#34; satu dua tiga Untuk mengakses salah satu anggota array:\n$ echo \u0026#34;${array[1]}\u0026#34; dua Associative array Hampir sama dengan array terindeks, untuk melihat value tiap anggota array asosiatif:\n$ echo \u0026#34;${array[@]}\u0026#34; Fulan Surabaya S1 Lajang Swasta Untuk melihat seluruh key dari tiap anggota array:\n$ echo \u0026#34;${!array[@]}\u0026#34; nama kota pendidikan status pekerjaan Untuk melihat value dari key tertentu:\n$ echo \u0026#34;${array[status]}\u0026#34; Lajang Mengakses array menggunakan loop Mengakses array menggunakan loop memungkinkan untuk melakukan sesuatu terhadap tiap-tiap isi array, baik itu array asosiatif atau terindeks.\n# _Indexed_ array $ arr=(satu dua tiga empat) $ for angka in ${arr[@]}; do echo \u0026#34;Putaran ke-$angka\u0026#34;; done Putaran ke-satu Putaran ke-dua Putaran ke-tiga Putaran ke-empat # Associative array $ declare -A arr=([nama]=Alan [kota]=Surabaya [asal]=Jakarta) $ for key in ${!arr[@]}; do echo \u0026#34;Data $key=\u0026gt; ${arr[$key]}\u0026#34;; done Data nama =\u0026gt; Alan Data kota =\u0026gt; Surabaya Data asal =\u0026gt; Jakarta Menambah isi array Cara menambah isi array adalah seperti berikut:\n$ array+=(empat lima) $ echo \u0026#34;${array[@]}\u0026#34; satu dua tiga empat lima # Untuk array asosiatif juga sama $ array+=([key]=value [key2]=value2) Mengubah string menjadi array $ var=\u0026#34;satu dua tiga empat lima\u0026#34; $ array=( $var ) # atau $ declare -a array \u0026lt;\u0026lt;\u0026lt; $var Penjelasan mengenai \u0026lt;\u0026lt;\u0026lt; ada pada artikel mendatang, insyaAllah.\nKasus penggunaan array Pada sebuah script, menentukan sekumpulan options dari suatu command tertentu. Misalnya, script tersebut menggunakan rsync dan ada sekumpulan options dan flag yang sudah ditentukan untuk setiap panggilannya.\n#!/usr/bin/env bash  rsync_options=(--archive --append --bwlimit=512k --progress ...) rsync() { rsync ${rsync_options[@]} .... }  Referensi:\n https://www.geeksforgeeks.org/bash-script-define-bash-variables-and-its-types https://www.shell-tips.com/bash/math-arithmetic-calculation  Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-variabel/","summary":"Pada artikel ini, saya akan menjelaskan bagaimana cara membuat variabel, array, dan lain-lain yang berkaitan, pada shell Bash.\nSeperti yang sudah pernah dibahas pada artikel Belajar Bash Scripting lain, bahwa tentunya Bash Scripting yang dibahas ini tidaklah POSIX-compliant atau istilahnya Bashism.\nAturan penamaan Dalam membuat variabel atau array, ketentuan dalam pemberian nama adalah sebagai berikut:\n Tidak diawali dengan angka. Tidak mengandung tanda pentung, tanda @, tanda pagar # dan asterisk (*).","title":"Belajar Bash Scripting: Variabel"},{"content":"Pada artikel ini saya akan menjelaskan mengenai bagaimana cara melakukan macam-macam kondisional pada Bash scripting. Dan karena ini adalah seri khusus shell Bash, maka tentunya tidak POSIX-compliant.\nKondisional IF Struktur dasar Struktur dasar kondisional if dalam Bash scripting hampir sama dengan keumuman bahasa pemrograman, yaitu seperti dibawah ini:\nif kondisi; then command command ... fi # atau if kondisi then command command ... fi Kondisi yang disebutkan diatas bisa berupa ekspresi perbandingan seperti contoh berikut:\nif [[ $var == xyz ]]; then command command fi # atau if test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34;; then command command fi Atau, bisa berupa command tertentu seperti:\n# Jika command1 sukses maka jalankan command2 dan seterusnya if command1; then command2 command3 ... fi # Contoh # Jika variabel $string mengandung substring xyz, maka jalankan command1 if grep -q \u0026#39;xyz\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$string\u0026#34;; then command1 fi Cara kerja Kondisional if akan menjalankan command di dalam blok jika kondisi yang diujikan memiliki exit status nol. Kedua contoh diatas ( sintaks [[ ... ]] atau test dan grep -q ) sebenarnya sama saja. Dalam artian bahwa sintaks [[ ... ]] sesungguhnya adalah command biasa yang bisa dijalankan diluar blok if. Bisa dicoba sendiri pada sesi shell seperti dibawah ini:\n[[ $var == \u0026#34;xyz\u0026#34; ]] \u0026amp;\u0026amp; echo true test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34; \u0026amp;\u0026amp; echo true Maka, jika variabel $var sama dengan string xyz, maka terminal akan mengeluarkan output \u0026ldquo;true\u0026rdquo;\nannahri@asus-zorin:/tmp$ var=xyz annahri@asus-zorin:/tmp$ [[ $var == \u0026#34;xyz\u0026#34; ]] \u0026amp;\u0026amp; echo true true annahri@asus-zorin:/tmp$ test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34; \u0026amp;\u0026amp; echo true true Ekspresi kondisional / Conditional expression Salah satu contoh ekspresi kondisional adalah seperti yang sudah dijelaskan sebelumnya, yaitu [[ $var == \u0026quot;xyz\u0026quot; ]] yang itu merupakan bentuk dari operator string.\nDisini saya hanya akan menjelaskan beberapa contoh ekspresi yang sering digunakan. Untuk lebih lengkapnya, bisa dibaca sendiri via command help test.\nannahri@asus-zorin:/tmp$ help test test: test [expr] Evaluate conditional expression. Exits with a status of 0 (true) or 1 (false) depending on the evaluation of EXPR. Expressions may be unary or binary. Unary expressions are often used to examine the status of a file. There are string operators and numeric comparison operators as well. ............. Operator file Operator file berfungsi untuk mencari tahu status suatu file. Apakah file tersebut ada, apakah file tersebut adalah suatu direktori, dan lain-lain.\n# Jika $file adalah file reguler if [[ -f $file ]]; then command fi # Jika $file adalah direktori if [[ -d $file ]]; then command fi # atau if test -d \u0026#34;$file\u0026#34;; then command fi Operator string Digunakan untuk melakukan perbandingan suatu variabel terhadap variabel lain atau string literal. Seperti yang sudah dijelaskan pada contoh awal misalnya.\nif [[ $string == \u0026#34;asdf\u0026#34; ]]; then command fi # atau negasinya if [[ $string != \u0026#34;asdf\u0026#34; ]]; then command fi # Jika $string kosong alias unset if [[ -z $string ]]; then command fi # Jika $string tidak kosong alias memiliki nilai if [[ -n $string ]]; then command fi Operator aritmatik Sesuai dengan judulnya, maka operator ini berfungsi untuk melakukan perbandingan aritmatis.\n# Jika $var sama dengan 10 if [[ $var -eq 10 ]]; then command fi # Jika $var tidak sama dengan 10 if [[ $var -ne 10 ]]; then command fi # Jika $var lebih besar dari 10 if [[ $var -gt 10 ]]; then command fi # Jika $var lebih besar atau sama dengan 10 if [[ $var -ge 10 ]]; then command fi # Jika $var lebih kecil dari 10 if [[ $var -lt 10 ]]; then command fi # Jika $var lebih kecil atau sama dengan 10 if [[ $var -le 10 ]]; then command fi Kondisi ganda (Operator AND dan OR) Melakukan evaluasi lebih dari satu kondisi dapat dilakukan dengan operator \u0026amp;\u0026amp; (AND) dan operator || (OR). Contoh penggunaannya adalah sebagai berikut:\n# Jika $val lebih besar dari 10 dan lebih kecil dari 20 if [[ $val -gt 10 \u0026amp;\u0026amp; $val -lt 20 ]]; then command fi # Jika $string tidak kosong dan $string tidak bernilai \u0026#34;xyz\u0026#34; if [[ -n $string \u0026amp;\u0026amp; $string != \u0026#34;xyz\u0026#34; ]]; then command fi # Jika $string tidak kosong atau $val lebih dari nol if [[ -n $string || $val -lt 0 ]]; then command fi Tidak terbatas hanya pada perbandingan variabel, namun operator AND dan OR juga bisa digunakan untuk mengevaluasi 2 command atau lebih.\nBiasanya ini digunakan untuk melakukan perintah yang memerlukan prekondisi dari perintah lain. Seperti memastikan suatu file berhasil dibuat terlebih dahulu sebelum melakukan command setelahnya.\n# Jika path /a/b/c berhasil dibuat dan jika file /a/b/c/d berhasil dibuat if mkdir -p /a/b/c \u0026amp;\u0026amp; touch /a/b/c/d; then command fi Negasi Untuk melakukan evaluasi yang sebaliknya, maka cukup untuk menambahkan sintaks ! sebelum memulai ekspresi atau sebelum [[ ... ]]. Contoh:\n# Jika $file tidak ada, alias kebalikan dari `-f` if [[ ! -f $file ]]; then command fi Beda penempatan operator negasi, juga berbeda pula dampaknya. Jika negasi ditaruh sebelum ekspresi, maka tiap-tiap ekspresi yang berada di konteks yang sama (berada pada satu kurung siku [[ ... ]]) bisa diberlakukan negasi masing-masing. Namun, jika tanda negasi ditaruh diluar seperti ! [[ ... ]] maka negasi diberlakukan setelah seluruh ekspresi yang ada didalamnya dievaluasi.\n# Masing-masing if [[ ! -f $file || ! -d $dir ]]; then command fi # Keseluruhan if ! [[ -z $string || -f $file ]]; then command fi IF berlapis/nested Kondisional if tentu saja bisa dilakukan secara berlapis alias nested.\nif konsisi 1; then command if kondisi 2; then command ... fi fi Bentuk IF ELSE Kondisional IF ELSE jika ekspresi yang dievaluasi tidak terpenuhi maka ELSE akan dijalankan\n# Jika kondisi 1 terpenuhi maka command1 akan dijalankan, jika tidak maka command2 yang akan dijalankan if kondisi 1; then command1 else command2 fi bentuk IF ELSE IF Kondisional IF ELSE IF merupakan bentuk evaluasi ekspresi yang berkelanjutan tetapi perintah-perintah yang ada di dalam kondisi tersebut yang akan dijalankan, alias tidak akan menjalankan 2 kondisi secara bersamaan.\n# Jika kondisi 1 terpenuhi maka command1 dijalankan, jika tidak,  # maka jika kondisi 2 terpenuhi, maka command2 akan dijalankan, namun jika tidak # maka jika kondisi 3 terpenuhi maka command3 akan dijalankan # tetapi jika seluruh kondisi tidak terpenuhi, maka command4 akan dijalankan if kondisi 1; then command1 elif kondisi 2; then command2 elif kondisi 3; then command3 else command4 fi Pada skenario diatas, jika variabel yang dievaluasi adalah variabel yang sama dan hendak mengevaluasi atas nilai-nilai tertentu, maka kondisional CASE-lah yang lebih cocok untuk digunakan. Contohnya sebagai berikut:\nif [[ $string == \u0026#34;a\u0026#34; ]]; then command1 elif [[ $string == \u0026#34;b\u0026#34; ]]; then command2 elif [[ $string == \u0026#34;c\u0026#34; ]]; then command3 . . . elif [[ $string == \u0026#34;z\u0026#34; ]]; then commandX else commandZ fi Bisa dilihat pada contoh diatas bahwa akan banyak pengulangan yang sebetulnya tidak perlu jika menggunakan kondisional CASE.\nKondisional CASE Kondisional CASE digunakan untuk melakukan evaluasi terhadap suatu variabel atau output command tertentu seperti pada contoh sebelumnya. Evaluasi yang dilakukan adalah ekspresi apakah variabel tersebut bernilai sekian atau sekian.\nStruktur dasar Kondisional CASE bisa memiliki beberapa bentuk/model dan merupakan preferensi masing-masing individu, tidak ada benar/salah.\nTetapi pada dasarnya, kondisional CASE diawali dengan case VARIABEL in kemudian diikuti dengan kondisi-kondisi. Tiap kondisi dibuka dengan PATTERN) (perhatikan tanda tutup kurung di akhir) dan ditutup dengan tanda ;;. Dan diakhiri dengan esac.\nBentuk yang umum adalah seperti ini:\n# Jika $string bernilai a, maka command1 dijalankan # Jika $string bernilai b, maka command2 dijalankan # Jika $string bernilai c, maka command3 dijalankan # namun jika tidak seluruhnya, maka commandZ akan dijalankan case \u0026#34;$string\u0026#34; in a) command1 ;; b) command2 ;; c) command3 ;; *) commandZ ;; esac Ada juga yang suka menulis blok CASE seperti ini, jika command untuk tiap kondisi tidaklah panjang.\ncase \u0026#34;$string\u0026#34; in a) command1 ;; b) command2 ;; c) command3 ;; *) commandZ ;; esac Operator OR Satu kondisi dalam CASE bisa diberi operator OR, contoh:\ncase \u0026#34;$string\u0026#34; in a|b) command1 ;; c|d) command2 ;; *) commandZ ;; esac Operator Wildcard * Operator wildcard * digunakan untuk mewakili satu atau lebih karakter. Contoh:\ncase \u0026#34;$string\u0026#34; in # Jika diawali dengan a a*) command1 ;; # Jika diawali dengan b dan diakhiri dengan c b*c) command3 ;; # Jika diakhiri dengan z *z) command4 ;; # Jika seluruh pattern tidak cocok *) commandZ ;; esac Perlu diperhatikan bahwa penempatan kondisi CASE sangat penting. Jika suatu kondisi/pattern yang bersifat lebih umum diletakkan lebih awal daripada yang lebih khusus, maka kondisi yang lebih khusus tersebut tidak akan pernah terevaluasi. Contoh:\n# Pola a*z sudah terwakili dengan pola sebelumnya (a*) # sehingga tidak akan terevaluasi. case \u0026#34;$string\u0026#34; in a*) command1 ;; a*z) command2 ;; esac  Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-conditional/","summary":"Pada artikel ini saya akan menjelaskan mengenai bagaimana cara melakukan macam-macam kondisional pada Bash scripting. Dan karena ini adalah seri khusus shell Bash, maka tentunya tidak POSIX-compliant.\nKondisional IF Struktur dasar Struktur dasar kondisional if dalam Bash scripting hampir sama dengan keumuman bahasa pemrograman, yaitu seperti dibawah ini:\nif kondisi; then command command ... fi # atau if kondisi then command command ... fi Kondisi yang disebutkan diatas bisa berupa ekspresi perbandingan seperti contoh berikut:","title":"Belajar Bash Scripting: Conditional"},{"content":"Sekedar dokumentasi dari permasalahan yang pernah saya jumpai. Terkadang dari sisi aplikasi tidak siap untuk dipublikasi secara HTTPS karena di dalam source code-nya masih ter-hardcoded beberapa resource eksternal menggunakan protokol HTTP.\nHal ini membuat kebanyakan web browser mengeluh dan enggan untuk memuat resource yang dipanggil dari protokol HTTP tadi.\nMaka solusinya ada 2:\n Edit source code-nya, ganti semua kode yang memanggil resource dari HTTP menjadi HTTPS. Dari sisi Reverse-Proxy, tinggal tambahkan header berikut:  add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; Kali ini saya akan membahas solusi untuk Reverse-Proxy Nginx\nContoh konfigurasi server block dan penempatan header :\nserver { listen 443 ssl http2; server_name namawebsite.tld; root /var/www/public_html; ... konfigurasi ssl ... add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; \u0026lt;-- Taruh disini, di dalam server block dan diluar block location location / { ... konfigurasi ... } } Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/jurnal-nginx-reverse-proxy-mixed-content/","summary":"Sekedar dokumentasi dari permasalahan yang pernah saya jumpai. Terkadang dari sisi aplikasi tidak siap untuk dipublikasi secara HTTPS karena di dalam source code-nya masih ter-hardcoded beberapa resource eksternal menggunakan protokol HTTP.\nHal ini membuat kebanyakan web browser mengeluh dan enggan untuk memuat resource yang dipanggil dari protokol HTTP tadi.\nMaka solusinya ada 2:\n Edit source code-nya, ganti semua kode yang memanggil resource dari HTTP menjadi HTTPS. Dari sisi Reverse-Proxy, tinggal tambahkan header berikut:  add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; Kali ini saya akan membahas solusi untuk Reverse-Proxy Nginx","title":"Jurnal: Membenahi kendala mixed-content pada Nginx Reverse-Proxy"},{"content":"Saya akan menjelaskan beberapa tips dan trik dalam menggunakan shell bash yang biasa saya gunakan sehari-hari.\nReverse Search Sebagian orang biasa menggunakan history untuk melihat/mencari command-command sebelumnya yang sudah pernah diinputkan. Atau bahkan menggunakan arrow key atas untuk mencari command yang diinginkan.\nSebenarnya hampir kebanyakan shell memiliki fitur reverse search. Sesuai namanya, fitur ini bisa melakukan pencarian terhadap command yang sebelumya pernah diinputkan.\nBagaimana caranya? Cukup menekan CTRL+Rpada terminal. Dan ketikkan kata kunci untuk command yang sedang dicari.\n(reverse-i-search)`apt\u0026#39;: sudo apt install hugo ^ ^ | |- history terakhir yang paling relevan |- keyword Sintaks Spesial !!, !$ dan !n Sintaks !! Pada bash shell (atau shell yang lain juga, mungkin) menrujuk kepada command terakhir yang diinputkan.\nJadi, jika sebelumnya kita menginputkan, misal, perintah echo abc. Lalu pada input berikutnya jika kita memasukkan !! maka, shell akan mengeksekusi kembali perintah echo abc.\nuser@host:~$ echo abc abc user@host:~$ !! echo abc \u0026lt;--- terminal tidak benar-benar mengeluarkan output ini, hanya sebagai penjelasan ekspansi shell saja abc Ini sangat berguna ketika kita lupa hendak menambahkan sudo pada suatu command yang panjang. Maka, pada input berikutnya, kita tinggal ketikkan sudo !! tanpa perlu mengetik ulang command sebelumnya.\nuser@host:~$ apt install -y package1 package2 package3 package4 package5 E: Could not open lock file /var/lib/dpkg/lock-frontend - open (13: Permission denied) E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), are you root? user@host:~$ sudo !! sudo apt install -y package1 package2 package3 package4 package5 ... Sintaks !$ Sintaks ini merujuk pada positional argument pada command terakhir. Sama seperti contoh sebelumnya, jika echo abc maka ekspansi dari !$ adalah abc.\nKasus penggunaan sintaks ini biasanya saat melakukan editing file. Seperti di bawah ini:\nuser@host:~$ cat /path/panjang/menuju/file isi file user@host:~$ vim !$ vim /path/panjang/menuju/file ... Jadi tidak perlu lagi mengetik ulang path panjang file yang dituju, tapi cukup gunakan sintaks !$ saja.\nSintaks !n Huruf n merujuk kepada angka pada history shell. Jika kita menjalankan perintah history maka tiap-tiap baris history terdapat angka disebelahnya (kecual jika konfigurasi untuk history sudah tidak default). Nah, dengan menggunakan !n maka shell akan mengulangi command yang sama sesuai dengan nomor yang tertera.\nContoh:\nuser@host:~$ history 1 ll 2 ls 3 lsblk 4 history user@host:~$ !1 ll total 20 drwxr-xr-x 1 user user 110 Nov 5 07:23 ./ drwxr-xr-x 1 root root 42 Nov 5 07:22 ../ -rw-r--r-- 1 user user 220 Nov 5 07:22 .bash_logout -rw-r--r-- 1 user user 3771 Nov 5 07:22 .bashrc drwx------ 1 user user 0 Nov 5 07:23 .cache/ drwxr-xr-x 1 user user 40 Nov 5 07:22 .config/ -rw-r--r-- 1 user user 5 Nov 5 07:22 .hidden -rw-r--r-- 1 user user 87 Nov 5 07:22 .inputrc -rw-r--r-- 1 user user 807 Nov 5 07:22 .profile Pintasan Clear Screen clear Command clear digunakan untuk membersihkan sesi layar shell. Agar lebih cepat, cukup tekan kombinasi tombol CTRL+L.\n Bersambung, insyaAllah\n","permalink":"https://blog.annahri.com/posts/trik-bash-shell-1/","summary":"Saya akan menjelaskan beberapa tips dan trik dalam menggunakan shell bash yang biasa saya gunakan sehari-hari.\nReverse Search Sebagian orang biasa menggunakan history untuk melihat/mencari command-command sebelumnya yang sudah pernah diinputkan. Atau bahkan menggunakan arrow key atas untuk mencari command yang diinginkan.\nSebenarnya hampir kebanyakan shell memiliki fitur reverse search. Sesuai namanya, fitur ini bisa melakukan pencarian terhadap command yang sebelumya pernah diinputkan.\nBagaimana caranya? Cukup menekan CTRL+Rpada terminal. Dan ketikkan kata kunci untuk command yang sedang dicari.","title":"Trik Bash Shell #1"},{"content":"Saya akan menjelaskan cara mudah untuk resize disk suatu VM dengan konfigurasi LVM. Asumsinya, disk sudah diextend dari sisi HVnya (PVE, ESXi, dll).\nPastikan penambahan space sudah terdeteksi dari VM melalui dmesg dan Anda akan mendapati informasi seperti ini:\n[262733.527587] sd 0:0:2:0: [abc] 4096-byte physical blocks [262733.528263] abc: detected capacity change from 214748364800 to 429496729600 Kalau ternyata belum terdeteksi, bisa dicoba untuk menjalankan perintah ini\necho 1 \u0026gt; /sys/class/block/\u0026lt;disk\u0026gt;/device/rescan Lalu coba cek kembali di dmesg. Kalau sudah muncul bisa langsung jalankan perintah berikut:\ngrowpart /dev/\u0026lt;disk\u0026gt; \u0026lt;no-partisi\u0026gt; # contoh `growpart /dev/sda 1` pvresize /dev/\u0026lt;partisi\u0026gt; # contoh `pvresize /dev/sda1` lvresize --extents +100%FREE --resizefs /dev/xxx/yyy # Value xxx yyy merujuk pada logical volume path Khusus untuk growpart jika tidak tersedia pada sistem Anda, maka bisa Anda gunakan parted\nparted /dev/\u0026lt;disk\u0026gt; (parted) resizepart \u0026lt;no-partisi\u0026gt; 100% (parted) quit Selesai. Semoga bermanfaat, insyaAllah\n","permalink":"https://blog.annahri.com/posts/jurnal-cara-extend-vm-disk-lvm/","summary":"Saya akan menjelaskan cara mudah untuk resize disk suatu VM dengan konfigurasi LVM. Asumsinya, disk sudah diextend dari sisi HVnya (PVE, ESXi, dll).\nPastikan penambahan space sudah terdeteksi dari VM melalui dmesg dan Anda akan mendapati informasi seperti ini:\n[262733.527587] sd 0:0:2:0: [abc] 4096-byte physical blocks [262733.528263] abc: detected capacity change from 214748364800 to 429496729600 Kalau ternyata belum terdeteksi, bisa dicoba untuk menjalankan perintah ini\necho 1 \u0026gt; /sys/class/block/\u0026lt;disk\u0026gt;/device/rescan Lalu coba cek kembali di dmesg.","title":"Jurnal: Cara Extend VM Disk untuk LVM"},{"content":"LEMP stack adalah software stack yang terdiri dari (L)inux, (E)gin-x alias Nginx, (M)ysql atau Mariadb, dan (P)HP.\nDi sini, saya akan menjelaskan bagaimana cara instalasi LEMP stack pada Ubuntu 20.04. Untuk OS berbasis RPM menyusul.\nKonfigurasi Awal Pastikan repositori Anda sudah pada kondisi terbaru dan package pada sistem anda terupgrade.\n$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Jika menggunakan firewall, pastikan port 80 (HTTP) dan 443 (HTTPS) terbuka. Kalau anda menggunakan ufw maka perintahnya adalah:\n$ sudo ufw allow proto tcp from any to any port 80,443 Gunakan perintah dibawah ini kalau Anda menggunakan iptables:\n$ sudo iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT # agar rule diatas menjadi \u0026#39;permanen\u0026#39; $ iptables-save | sudo tee /etc/iptables/rules.v4 Instalasi Stack Selanjutnya instal nginx, mariadb, dan php-fpm :\n$ sudo apt install -y \\  nginx \\  mariadb-server mariadb-common \\  php7.4-fpm php7.4 php7.4-common php7.4-mysql Pastikan semua service berjalan dengan baik :\n$ sudo systemctl status nginx $ sudo systemctl status mariadb $ sudo systemctl status php7.4-fpm Jika belum berjalan, maka jalankan service-service tersebut dengan perintah:\n$ sudo systemctl enable nginx --now $ sudo systemctl enable mariadb --now $ sudo systemctl enable php7.4-fpm --now Kemudian cek juga apakah port 80 sudah listen atau belum.\n$ sudo ss -tulpn | grep \u0026#39;:80\u0026#39; Untuk port 443 masih belum. Karena setelah instalasi baru, secara asal port 80 yang listen.\nTes Web Server Untuk itu, silahkan coba buka browser menggunakan alamat IP server. Atau juga bisa menggunakan domain. Jika memang sudah diatur A recordnya.\nAtau, pengecekan bisa dilakukan dengan menggunakan curl :\n$ curl localhost \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tes Halaman PHP Buat file php dengan isi berikut, simpan di /var/www/html/phpinfo.php:\n\u0026lt;?php phpinfo(); ?\u0026gt;Kemudian pada browser / curl, silahkan coba akses http://IP SERVER/phpinfo.php:\n$ curl localhost/phpinfo.php \u0026lt;?php phpinfo(); ?\u0026gt; Kok tidak berhasil? Ya, karena nginx belum diatur untuk memproses halaman php.\nEdit file /etc/nginx/sites-available/default.conf kemudian cari baris berikut, dan hilangkan pagar-pagar didepannya (alias uncomment) :\nlocation ~ \\.php$ { include snippets/fastcgi-php.conf; # # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; } Sederhananya, blok diatas menginstrusikan nginx untuk memproses seluruh file yang berakhiran .php kepada php-fpm. Bisa melalui socket unix (unix:/path/to/socket.sock) atau socket tcp (IP:port).\nSetelah itu, reload konfigurasi nginx sudo nginx -s reload dan tes kembali menggunakan curl atau browser.\n$ curl localhost/phpinfo.php Jika menghasilkan halaman info php, maka konfigurasi sudah benar.\nKonfigurasi dan Tes Konektivitas Database Biasakan untuk selalu menjalankan mysql_secure_installation setiap kali menginstall mariadb-server atau mysql-server. Karena sesuai dengan namanya, perintah tersebut memastikan instalasi mysql itu aman alias secure.\n$ sudo mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we\u0026#39;ll need the current password for the root user. If you\u0026#39;ve just installed MariaDB, and you haven\u0026#39;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] Y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y Y ... Success! Normally, root should only be allowed to connect from \u0026#39;localhost\u0026#39;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] Y ... Success! By default, MariaDB comes with a database named \u0026#39;test\u0026#39; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y ... Success! Cleaning up... All done! If you\u0026#39;ve completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! Jawab setiap promptnya dengan Y.\nKemudian kita buat satu database percobaan dan satu database user.\n$ sudo mysql CREATEDATABASEtesdb;CREATEUSERdbuser@localhostIDENTIFIEDBY\u0026#39;password\u0026#39;;GRANTALLPRIVILEGESONtesdb.*TOdbuser@localhost;FLUSHPRIVILEGES;Buat satu file untuk uji coba konek php ke database. Simpan di /var/www/html/tesdb.php\n\u0026lt;?php $con = mysqli_connect(\u0026#34;localhost\u0026#34;,\u0026#34;dbuser\u0026#34;,\u0026#34;password\u0026#34;,\u0026#34;tesdb\u0026#34;); if (mysqli_connect_errno()) { echo \u0026#34;Failed to connect to MySQL: \u0026#34; . mysqli_connect_error(); exit(); } else { echo \u0026#34;Koneksi Database Berhasil.\u0026#34;; } ?\u0026gt;Tes kembali menggunakan browser atau curl, buka http://IP SERVER/testdb.php\n$ curl localhost/testdb.php Koneksi Database Berhasil. Selesai!\n Kesimpulan Begitu mudahnya untuk melakukan instalasi LEMP stack pada Ubuntu 20.04. Cukup menginstal nginx + mysql/mariadb + php-fpm, dan sedikit konfigurasi pada nginx.\nTentunya akan memerlukan konfigurasi lebih lanjut jika hendak menginstal webapp semacam wordpress, dan semisalnya.\nSemoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/lemp-stack-ubuntu20-04-focal/","summary":"LEMP stack adalah software stack yang terdiri dari (L)inux, (E)gin-x alias Nginx, (M)ysql atau Mariadb, dan (P)HP.\nDi sini, saya akan menjelaskan bagaimana cara instalasi LEMP stack pada Ubuntu 20.04. Untuk OS berbasis RPM menyusul.\nKonfigurasi Awal Pastikan repositori Anda sudah pada kondisi terbaru dan package pada sistem anda terupgrade.\n$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Jika menggunakan firewall, pastikan port 80 (HTTP) dan 443 (HTTPS) terbuka. Kalau anda menggunakan ufw maka perintahnya adalah:","title":"Instalasi LEMP Stack (Linux, Nginx, MariaDB, PHP) pada Ubuntu 20.04"}]