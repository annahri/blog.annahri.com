[{"content":" Mukadimah Pada artikel ini, saya akan menceritakan bagaimana saya berhasil menyelamankan dan mengembalikan paritisi LVM yang hilang metadatanya karena tertimpa oleh metadata SWAP.\nHal ini terjadi diduga karena sang \u0026ldquo;user\u0026rdquo; nampaknya ingin membesar kapasitas RAM dengan menambah ukuran SWAP. Alih-alih membuatnya pada suatu file atau partisi baru, si \u0026ldquo;user\u0026rdquo; tersebut membuatnya di partisi dimana root disk berada.\nSejurus kemudian, muncullah permintaan reboot VM yang dimaksud. Tanpa pikir panjang, rekan saya melakukan reboot. Ditunggu beberapa saat kok tidak kunjung UP, diintiplah via console, dan jeng-jeng-jeng, sistem gagal booting dan fallback ke initramfs dengan pesan error bahwa logical volume untuk root partition tidak ditemukan.\nPemecahan masalah Melihat pesan error yang muncul pada saat booting tersebut, ada inidikasi bahwa root partition telah \u0026ldquo;rusak\u0026rdquo; dan sistem tidak mengenalinya lagi atau bahkan tidak menemukannya.\nKemudian, pengecekan menggunakan Live Image ISO Ubuntu 18.04, bisa didapati bahwa susunan layout partisi adalah layout standar jika Ubuntu diinstall menggunakan opsi Guided LVM. yaitu partisi boot terpisah dan sisanya untuk LVM:\nSaat dicek menggunakan blkid, tertulis bahwa sda5 adalah partisi SWAP sedangkan fdisk menunjukkan bahwa sda5 adalah partisi LVM. Dari sini saya berasumsi bahwa yang terjadi adalah sempat ada upaya untuk membuat partisi SWAP namun keliru dan menimpa metadata LVM pada partisi sda5.\nKemudian, saya coba untuk memuat partisi LVM tersebut dengan memindainya menggunakan lvmdiskscan. Dalam situasi normal dan ideal, seharusnya tool tersebut akan memberikan output seperti ini:\nroot@host:~# lvmdiskscan | grep -v loop /dev/localhost/root [ 16.27 GiB] /dev/sda1 [ 1.40 GiB] /dev/localhost/swap [ 2.33 GiB] /dev/sda5 [ 23.60 GiB] LVM physical volume 2 disks 4 partitions 0 LVM physical volume whole disks 1 LVM physical volume Dimana partisi LVM akan bisa dideteksi dan diidentifikasi. Jika demikian kondisinya, maka cukup dimuat dengan cara berikut:\n# pvscan # vgscan # vgchange -ay # mount ... Namun kondisinya adalah, partisi yang ditengarai sebagai LVM tersebut tidak dikenali oleh sistem sebagai partisi LVM yang valid karena telah rusak metadatanya.\nBermodalkan dengan sedikit kemampuan googling, saya menemukan beberapa artikel yang menunjukkan bagaimana cara memulihkan partisi LVM2 beserta anak-anaknya (PV, VG, LV dan metadatanya). Diantara artikel yang paling membantu adalah ini.\nDi artikel tersebut dijelaskan, yang pada intinya, bahwa hal yang berperan penting dalam pemulihan tersebut adalah file backup metadata LVM, yang secara asal, selalu disimpan di /etc/lvm/backup/\u0026lt;nama VG\u0026gt;\nPertanyaannya, bagaimana cara mendapatkan file tersebut dalam keadaan file itu ada di dalam partisi yang \u0026ldquo;rusak\u0026rdquo; dan tidak bisa dimount tersebut?\nIseng-iseng saya coba untuk melakukan less -sr pada partisi yang dimaksud, dan hasilnya, partisi tersebut bisa dilihat bahwa file-file yang ada didalamnya bisa dibaca. Alhamdulillah, sebuah titik terang yang berarti file metadata yang dicari, seharusnya bisa \u0026ldquo;diambil\u0026rdquo;.\nBerkenalan dengan sang tool \u0026ldquo;penyelamat\u0026rdquo; Kembali menyelami tumpukan jerami google demi mencari sang \u0026ldquo;jarum\u0026rdquo;, satu ketemulah satu forum yang sedang membahas permasalahan yang serupa (tapi berbeda). Salah satu jawabannya menjelaskan tentang tool testdisk yang mampu melakukan recovery file pada suatu partisi yang diduga \u0026ldquo;rusak\u0026rdquo; atau memang benar-benar rusak.\nSingkat cerita, cukup dengan menjalankan testdisk /dev/sda5, kemudian dilakukan pemindaiaan, dan akhirnya muncul TUI (Text-based User Interface) seperti file explorer yang mana kita bisa eksplorasi file-file di dalam partisi yang sedang diperiksa tersebut, lengkap dengan struktur direktorinya juga! Masya Allah, mantap betul tool ini!\nDengan bantuan tool tersebut, file metadata backup yang dicari-pun berhasil untuk didapatkan!\nPemulihan partisi LVM Pembuatan ulang PV (Physical Volumes) kini bisa dilakukan dengan bermodalkan file backup tadi. Tetapi sebelunya perlu dicatat UUID dari partisi LVM yang hendak dibuat ulang tersebut. Ini bisa didapatkan dengan membuka file backup tadi, kemudian mencocokkannya dengan hasil UUID yang didapatkan via perintah blkid.\nPada bagian bawah tangkapan layar diatas, UUID yang dimaksud ada di bagian:\npv0 { id = UUID \u0026lt;----------------------- DISINI device = /dev/sda5 # Hint Only ... Kemudian, copy UUID tersebut yang nantinya akan digunakan untuk membuat ulang partisi LVM. Perintahnya adalah seperti ini:\npvcreate --restorefile \u0026lt;file backup\u0026gt; --uuid \u0026lt;uuid\u0026gt; /dev/sdaX Dapat diperhatikan pada tangkapan layar sebelumnya, terdapat pesan warning yang berbunyi \u0026ldquo;swap signature detected on /dev/sda5\u0026rdquo;. Sehingga, memang benar dugaan kuat di awal terkait penyebab rusaknya partisi LVM ini.\nKemudian jika dicek menggunakan pvs atau pvdisplay, maka tentu PV yang dimaksud akan muncul.\nLangkah selanjutnya adalah memulihkan VG (Volume Group) yang ada di dalam PV tersebut. Caranya cukup dengan menjalankan perintah berikut:\nvgcfgrestore -f \u0026lt;file backup\u0026gt; \u0026lt;nama VG\u0026gt; Kemudian aktifkan seluruh LV (Logical Volumes) yang ada di VG tersebut dengan cara:\nvgchange -ay Dengan demikian, jika dicek menggunakan lvs atau lsblk, maka akan muncul semua LV yang ada:\nNah, disini muncul permasalahan baru. Kenapa UUID untuk masing-masing LV kok tidak terlihat di output lsblk diatas? Dari sini sempat saya coba untuk mount /dev/localhost/root /mnt tetapi hasilnya gagal dengan error \u0026ldquo;\u0026hellip;wrong fs type\u0026hellip;\u0026rdquo;\nSetelah ditelusuri lebih lanjut, jika melihat pada pesan error yang muncul saat mengaktifkan VG, ada indikasi bahwa partisi /dev/sda5 memiliki ukuran sektor yang lebih kecil daripada ukuran PV. Maka, kemungkinannya adalah, dengan adanya perbedaan ukuran tersebut, tiap-tiap partisi LV, memiliki starting sektor yang tergeser. Sehingga, metadata yang ada didalamnya tidak dikenali oleh sistem, dan UUID tidak muncul sebagaimana mestinya.\nSetelah brainstorming dengan rekan senior saya, diputuskan untuk membuat ulang susunan partisi menggunakan fdisk. Singkatnya, saya hapus partisi 5 (lvm) kemudian partisi 2 (extended), setelah itu buat partisi baru lagi dengan susunan yang sama.\nDan perlu diperhatikan pula, saat membuat ulang partisi ke 5, jangan sampai menghapus LVM2_member signaturenya. Setelah itu, sistem perlu direboot karena partisi LVM tersebut masih \u0026ldquo;terpakai\u0026rdquo;.\nKemudian, setelah reboot (setelah mengatur live cd, dst), maka sekarang tiap partisi LV sudah muncul UUIDnya. Nah, disini ketemu dengan permasalahan baru. Partisi /dev/sda5 dan partisi /dev/localhost/swap memiliki UUID yang sama.\nDisini cukup mudah. Tinggal saya buat ulang saja partisi SWAPnya menggunakan mkswap /dev/localhost/swap. Dengan demikian, partisi tersebut akan terlahir kembali dengan UUID baru.\nNah, sekarang pengujian akhir yaitu melakukan uji mounting partisi root dengan mount /dev/localhost/root /mnt, dan hasilnya:\nDisini saya cukup percaya diri bahwa sistem akan berhasil boot, maka langsung reboot saja.\nAlhamdulillah, sistem berhasil dipulihkan!!\nFaidah yang bisa diambil Dari kisah ini, ada beberapa hal penting yang bisa diambil pelajaran:\nBackup data Anda! Seluruh aktivitas diatas terjadi karena tidak adanya backup. Dan perlu untuk ditekankan, bahwa backup seharusnya berada di tempat terpisah dengan objek backup. File penting untuk sistem yang menggunakan filesystem LVM salah satunya adalah file backup metadata yang terletak di /etc/lvm/backup. Jangan lakukan sesuatu yang kita tidak tahu ilmunya, dan yang tidak pada tempatnya. Melakukan sesuatu pada environment production sama seperti berjalan di tepi jurang. Jika ragu, maka serahkan pada yang ahli. Pentingnya skill googling dalam pemecahan masalah. Perlu untuk mengetahui kata kunci yang tepat agar bisa mendapatkan hasil yang juga tepat sasaran. Menurut saya ini adalah skill utama untuk praktisi IT. Sekian artikel kali ini. Semoga memberikan manfaat bagi pembaca, barakallahufiikum.\n","permalink":"https://blog.annahri.com/posts/jurnal-menyelamatkan-partisi-lvm-yang-rusak/","summary":"Mukadimah Pada artikel ini, saya akan menceritakan bagaimana saya berhasil menyelamankan dan mengembalikan paritisi LVM yang hilang metadatanya karena tertimpa oleh metadata SWAP.\nHal ini terjadi diduga karena sang \u0026ldquo;user\u0026rdquo; nampaknya ingin membesar kapasitas RAM dengan menambah ukuran SWAP. Alih-alih membuatnya pada suatu file atau partisi baru, si \u0026ldquo;user\u0026rdquo; tersebut membuatnya di partisi dimana root disk berada.\nSejurus kemudian, muncullah permintaan reboot VM yang dimaksud. Tanpa pikir panjang, rekan saya melakukan reboot.","title":"Jurnal: Menyelamatkan Partisi LVM Yang Metadatanya Tertimpa"},{"content":" Mukadimah Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.\nIni akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:\n./script.sh -u username -h host # or ./script.sh --username user --host hostname Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya.\nPositional Argument Yang dimaksud dengan positional argument, secara umum adalah argumen yang ditentukan dari urutannya ($1 .. $n), dan secara khusus, yaitu argumen yang sudah ditetapkan tujuannya sesuai dengan urutan penyebutannya. Misalnya pada tool rsync:\nrsync sourcefiles user@remote:/destination/ Bisa didapati bahwa argumen pertama merupakan spesifikasi untuk file sumber yang hendak ditransfer kemudian argumen terakhir adalah tujuannya, entah di lokal atau remote.\nSehingga, argumen pertama akan selalu menjadi sumber file dan argumen kedua akan selalu menjadi tujuannya. Jikalau dibalik, tidak bisa, destinasi tujuan didefinisikan pada argumen pertama dan seterusnya.\nAtau pada utilitas mv atau cp, yang ketentuannya adalah jika diberikan 2 nama file, maka yang pertama menjadi sumber file dan yang kedua menjadi tujuan file (hasil salinan, atau hasil pindahan). Namun, jika diberikan lebih dari 2 file, maka argumen paling akhir akan menjadi tujuannya.\ncp file1 file2 file3 target/ mv fileA fileB fileXYZ target/ Maka sudah menjadi ketentuan, bahwa file/folder yang disebutkan paling akhir, maka file/folder tersebut akan menjadi targetnya.\nInilah yang dimaksud dengan positional argument.\nOptional Argument Optional argument adalah argument yang tidak wajib untuk diberikan. Boleh diberikan dan boleh juga tidak. Ini berfungsi untuk mengubah sifat suatu tool berdasarkan flag/option yang diberikan. Misalkan pada rysnc:\nrsync --dry-run --delete sourcefiles user@remote:/destination/ Lho, katanya argumen pertama itu untuk spesifikasi file/folder sumber dan argumen kedua untuk tujuannya? Bukankah pada contoh ini, argumen pertama ($1) adalah --dry-run? kemudian argumen kedua adalah --delete? dan yang ketiga dan keempat baru sumber dan tujuan?\nJawabannya, benar. Jika diruntut, memang terbaca seperti itu ($1 = '--dry-run' dan seterusnya). Ini karena argument parsing. Tiap argumen yang diberikan akan diproses satu-persatu menyesuaikan dengan pola argumen yang diberikan.\nTool rsync tersebut, diprogram sedemikian rupa sehingga ketika didapati ada argument yang berawalan -- atau - maka akan dianggap sebagai optional parameter, dan akan diproses berdasarkan string setelahnya. Misalnya pada contoh diatas, --dry-run maka rysnc akan berjalan pada mode dry run alias percobaan.\nArgument Parsing Argument parsing sebenarnya bisa dilakukan dengan built-in tool getopts. Namun, pada artikel ini saya hanya akan membahas argument parsing menggunakan while dan for loop yang dikombinasikan dengan kondisional case.\nContoh skenarionya adalah seperti ini:\n./script.sh -a -b opt1 --xyz opt2 pos1 pos2 Maka akan didapatkan variabel $@ yang isinya:\n-a -b opt1 --xyz opt2 pos1 pos2 dan $# yang bernilai 7.\n💡 Variabel $# bernilai sejumlah dengan seluruh argumen yang diberikan.\nDengan demikian maka bisa diproses masing-masing argumennya dengan loop berikut:\n#!/usr/bin/env bash while [[ $# -ne 0 ]]; do case \u0026#34;$1\u0026#34; in -a) option_a=\u0026#34;set\u0026#34; shift ;; -b) option_b=\u0026#34;$2\u0026#34; shift 2 ;; --xyz) option_xyz=\u0026#34;$2\u0026#34; shift 2 ;; *) positional_arg+=( \u0026#34;$1\u0026#34; ) shift ;; esac done printf \u0026#39;%s: %s\\n\u0026#39; option_a \u0026#34;$option_a\u0026#34; option_b \u0026#34;$option_b\u0026#34; option_xyz \u0026#34;$option_xyz\u0026#34; echo \u0026#34;Positional args: ${positional_arg[*]}\u0026#34; Penjelasan Bagian while [[ $# -ne 0 ]]; do akan melakukan loop selama $# tidak bernilai nol, alias selama masih ada argumen yang bisa diproses, pemrosesan akan terus berlanjut.\nKemudian case \u0026quot;$1\u0026quot; in akan mengecek argumen pertama dan akan mecocokkannya dengan case-case yang didefinisikan setelahnya. Kenapa hanya argumen pertama saja? Akan datang penjelasannya nanti.\nCase-case yang dimaksud adalah seperti pada contoh, adalah -a, -b, --xyz dan *. Mari dibahas satu-persatu:\n-a) option_a=\u0026#34;set\u0026#34; shift ;; Nah, ketika $1 bernilai -a, maka kita akan definisikan variabel option_a dengan nilai set. Kemudian ada sintaks shift, yang berfungsi untuk menggser positional parameter yang diberikan. Maksudnya bagaimana?\nSeperti yang sudah diketahui sebelumnya, bahwa pada contoh command sebelumnya, argumen-argumen yang diberikan adalah sebagai berikut:\n-a -b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 $5 $6 $7 # $# = 7 Jika command shift dipanggil, maka penyematan argumen akan menjadi seperti ini:\n-a -b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 $5 $6 # $# = 6 Kemudian, jika shift dipanggil dan diberikan nilai padanya, maka pergeseran argumen akan dilakukan sebanyak nilai yang diberikan. Misalnya shift 2:\n-a -b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 # $# = 4 Karena positional argument-nya bergeser, maka jumlahnya ($#) juga berubah pula, sebagaimana pada contoh diatas.\nKembali ke pembahasan sebelumnya, karena kondisi $1 saat ini bernilai -a maka kita isikan variabel option_a dengan nilai set dan kita geser positional argumen selanjutnya menggunakan perintah shift. Sehingga kondisi $1 saat ini menjadi argumen setelahnya, tidak lagi -a.\nSetelah shift diberlakukan, maka pengkondisian case selesai dan kembali kepada loop untuk melakukan iterasi berikutnya karena $# masih belum bernilai 0. Selanjutnya:\n-b) option_b=\u0026#34;$2\u0026#34; shift 2 ;; dengan kondisi $@ yang saat ini adalah seperti berikut ini:\n-b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 $5 $6 maka, karena $1 saat ini bernilai -b maka kita deklarasikan variabel option_b dengan memberikannya nilai sesuai dengan nilai variabel $2 yaitu opt1. Setelah itu kita geser kembali argumennya 2 kali. Sehingga, kondisi $@ saat ini menjadi:\n--xyz opt2 pos1 pos2 $1 $2 $3 $4 Untuk bagian dibawah ini, pembahasannya sama dengan -b:\n--xyz) option_xyz=\u0026#34;$2\u0026#34; shift 2 ;; Kemudian yang terkahir adalah:\n*) positional_arg+=( \u0026#34;$1\u0026#34; ) shift ;; Ini berarti, semua argumen yang bukan berupa option (diawali dengan -), maka akan teranggap sebagai positional argument dan akan dimasukkan ke array positional_arg yang akan diproses tersendiri nantinya.\nDengan demikian, output dari command berikut ini:\n./script.sh -a -b opt1 --xyz opt2 pos1 pos2 adalah\noption_a: set option_b: opt1 option_xyz: opt2 Positional args: pos1 pos2 Parsing bentuk \u0026ndash;opt=value dan -oValue Setelah dijelaskan konsep dasar pemanfaatan WHILE loop dan CASE statement untuk argument parsing seperti pada contoh sebelumnya, saya akan jelaskan pula bagaimana cara untuk membuat parsing dengan model seperti ini:\n./script.sh --opt1=value1 --flag1=value2 ... Susunan WHILE loop sama seperti dengan contoh sebelumnya, namun bisa diperingkas seperti berikut agar mengurangi kedalaman indentasi:\n#!/usr/bin/env bash while [[ $# -ne 0 ]]; do case \u0026#34;$1\u0026#34; in --flag1=*) var_flag1=\u0026#34;${1#*=}\u0026#34;;; --opt1=*) var_opt1=\u0026#34;${1#*=}\u0026#34; ;; *) echo \u0026#34;Opsi tidak dikenali.\u0026#34;; exit 1;; esac; shift; done printf \u0026#39;%s: %s\\n\u0026#39; \\ \u0026#39;Flag1\u0026#39; \u0026#34;$var_flag1\u0026#34; \\ \u0026#39;Opt1\u0026#39; \u0026#34;$var_opt1\u0026#34; 💡 Sintaks shift pada contoh ini tidak lagi diletakkan pada tiap-tiap case yang diberikan karena itu redundan. Sehingga cukup diletakkan sekali saja setelah block case diakhir tiap loop.\nNah, pada contoh diatas, saya memanfaatkan suatu fitur dari Bash yaitu parameter expansion yang akan dibahas lebih detail pada artikel lain nantinya.\nParameter expansion yang dimanfaatkan adalah ${variabel#*PATTERN} yang fungsinya adalah menghapus seluruh karakter dari awal hingga bertemu PATTERN. Pada contoh diatas adalah ${1#*=}.\nAnggap saja nilai $1 saat ini adalah --flag1=hehe, fokus pada parameter #*=, maka bisa diartikan dengan \u0026ldquo;menghapus seluruh karakter dari awal hingga bertemu dengan karakter = (inklusif)\u0026rdquo;. Sehingga hasilnya adalah hehe.\nKemudian, contoh selanjutnya adalah argument parsing semisal pada command mysql:\nmysql -uroot -hhostname -p Hampir sama dengan contoh sebelumnya, hanya berbeda pada sintaks parameter expansion saja dan pada klausa CASEnya:\n#!/usr/bin/env bash while [[ $# -ne 0 ]]; do case \u0026#34;$1\u0026#34; in -u*) username=\u0026#34;${1#*-u}\u0026#34;;; -h*) password=\u0026#34;${1#*-h}\u0026#34;;; -p) prompt_password=1 ;; *) echo \u0026#34;Opsi tidak dikenali.\u0026#34;; exit 1;; esac; shift; done printf \u0026#39;%s: %s\\n\u0026#39; \\ \u0026#39;Username\u0026#39; \u0026#34;$username\u0026#34; \\ \u0026#39;Hostname\u0026#39; \u0026#34;$hostname\u0026#34; if [[ -n \u0026#34;$prompt_password\u0026#34; ]]; then read -r -s -p \u0026#34;Kata sandi: \u0026#34; password fi Argument parsing dengan FOR loop FOR loop juga bisa digunakan untuk melakukan argument parsing. Namun dengan batasan, bahwa argument parsing yang dilakukan tidak bisa berupa opsi/flag yang meminta value. Hanya bisa berupa opsi/flag yang bersifat toggle (alias, on/off) dan juga positional argument saja. Misal:\n./script.sh --force --delete #!/usr/bin/env bash for arg in \u0026#34;$@\u0026#34;; do case \u0026#34;$arg\u0026#34; in --force) force_enable=true ;; --delete) delete_enable=true ;; *) echo \u0026#34;Opsi tidak dikenali.\u0026#34;; exit 1 ;; esac; done ... Pada model ini, kita memanfaatkan variabel $@ dan tidak perlu memanggil shift karena tiap iterasinya, FOR loop akan mengkonsumsi semua ekspansi $@ satu persatu. Bentuknya menjadi lebih ringkas namun kurang fleksibel.\nValidasi Tentunya, setiap pemberian opsi dan/atau positional argument perlu diberlakukan validasi terlebih dahulu. Misalnya script tidak memperbolehkan penggunaan flag/opsi yang sama lebih dari satu, atau jika opsi yang satu sudah diberikan maka opsi yang lain tidak boleh diberikan pula.\nStrategi untuk mengatasi kondisi semacam itu beragam. Diantaranya bisa dengan misalnya opsi yang terakhir diberikan maka itu yang akan dipertimbangkan. Atau pemberian prioritas, atau bahkan script akan error jika bertemu kondisi-kondisi tersebut.\nHal ini bisa dilakukan langsung pada bagian kondisional CASE atau setelah argument parsing selesai.\nContohnya pada utilitas mv atau rm pada opsi -i dan -f-nya:\nrm -i -f file2 Opsi -i berfungsi agar perintah rm memberikan prompt sebelum penghapusan file dilakukan. Sedangkan -f adalah opsi yang digunakan agar rm menghapus \u0026ldquo;paksa\u0026rdquo; suatu file tanpa menanyakan/memberitahukan terkait ada/tidaknya file yang dimaksud. Tentu keduanya bertentangan satu sama lain. Bagaimana rm menangani kondisi ini? Yaitu dengan memprioritaskan opsi yang paling akhir.\nSehingga bisa saja suatu script disusun seperti ini untuk meniru gaya argument parsing pada cp:\n... while [[ $# -ne 0 ]]; do case \u0026#34;$1\u0026#34; in ... -i) option=\u0026#34;interactive\u0026#34;; shift ;; -f) option=\u0026#34;force\u0026#34;; shift ;; ... esac done ... dengan demikian, variabel option akan memiliki nilai sesuai dengan opsi yang ditentukan paling akhir.\nKemudian, suatu script dimana script tersebut memerlukan variabel tertentu agar diset oleh user, namun jika tidak diberikan, variabel tersebut akan terisi dengan nilai default. Misalnya pada tool iptables. Tool tersebut memerlukan ditentukannya nama tabel agar bisa menampilkan semua rules-nya dengan flag -L.\niptables -t nat -L Jika, opsti -t nat tidak diberikan, maka secara asal, iptables akan menampilkan rules pada tabel filter. Contoh pada script:\n... while [[ $# -ne 0 ]]; do case \u0026#34;$1\u0026#34; in ... -t) table=\u0026#34;$2\u0026#34;; shift 2 ;; ... esac done ... if [[ -z \u0026#34;$table\u0026#34; ]]; then table=filter fi atau lebih sederhana, menggunakan parameter expansion:\n... case \u0026#34;$1\u0026#34; in ... -t) table=\u0026#34;${2:-filter}\u0026#34;; shift 2 ;; ... esac ... ☝️ Yang maknanya, jika variabel $2 itu UNSET atau bernilai kosong (empty string), maka isi variabel table dengan string filter.\nBagaimana dengan bentuk option/flag seperti contoh dibawah ini?\ntar xvzf archive.tar.gz # atau rsync rsync -avznP source/ user@host:/dest/ # atau ps ps aux # atau ss/netstat ss -ant netstat -patlun Saya serahkan pada pembaca untuk mencari tahu.\nSemoga bermanfaat, barakallahufiikum.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-argument-parsing/","summary":"Mukadimah Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.\nIni akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:\n./script.sh -u username -h host # or ./script.sh --username user --host hostname Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya.","title":"Belajar Bash Scripting: Argument Parsing"},{"content":" Pada artikel kali ini, saya akan membahas mengenai shell argumens, yaitu bagaimana agar kita dapat memasukkan parameter tertentu saat memanggil script yang telah kita tulis atau saat memanggul fungsi yang telah kita definisikan.\nParameter/argumen Mari kita lihat pada command cp berikut ini:\ncp -f file1 file2 Command diatas bisa diartikan dengan \u0026ldquo;menyalin secara paksa file1 sebagai file2\u0026rdquo;.\nPaksaan yang dimaksud adalah jika file2 sebelumnya telah ada, maka langsung menimpa file2 tersebut dengan file1tanpa memberitahu user terlebih dahulu. Pada command cp, struktur dasar penggunaannya adalah:\ncp [OPSI] \u0026lt;FILE SUMBER\u0026gt; \u0026lt;FILE TUJUAN\u0026gt; Sintaks yang berada dalam kurung kotak, merupakan parameter opsional, alias boleh diberi boleh tidak. Kemudian dalam kurung lancip, adalah wajib. Maka pemberian parameter FILE SUMBER dan FILE TUJUAN adalah wajib.\nInterpretasi shell bash Jika sintaks diatas kita bedah satu persatu, maka shell bash akan menginterpretasikan masing-masing parameter/argumen yang diinputkan sebagai variabel-variabel yang bisa diakses. Variabel-variabel tersebut dimulai dari variabel $0 yang itu merupakan nama program/script yang dijalankan, kemudian $1 yang merupakan argumen pertama, hingga $n (dimana n adalah jumlah variabel).\nSehingga, pada contoh diatas, maka bisa didapatkan variabel-variabel berikut:\n$0 adalah cp $1 adalah -f $2 adalah file1, dan $3 adalah file2 Percobaan Sebagai pembuktian, mari dicoba dengan script coba.sh sederhana berikut ini:\n#!/usr/bin/env bash echo \u0026#34;\\$0 = $0\u0026#34; echo \u0026#34;\\$1 = $1\u0026#34; echo \u0026#34;\\$2 = $2\u0026#34; Hasil tesnya adalah\n$ ./coba.sh halo bismillah $0 = ./coba.sh $1 = halo $2 = bismillah Ini juga bisa digunakan untuk fungsi:\n#!/usr/bin/env bash main() { echo \u0026#34;\\$0 = $0\u0026#34; echo \u0026#34;\\$1 = $1\u0026#34; echo \u0026#34;\\$2 = $2\u0026#34; } main \u0026#34;uji\u0026#34; \u0026#34;coba\u0026#34; Maka saat dijalankan, akan mengeluarkan output:\n$ ./coba.sh $0 = ./coba.sh $1 = uji $2 = coba 💡 Disini perbedaannya adalah, $0 akan selalu merujuk pada program/shell script yang dijalankan, bukan fungsi yang dipanggil. Contoh script #!/usr/bin/env bash usage() { echo \u0026#34;Usage: $(basename $0) \u0026lt;nama\u0026gt;\u0026#34; exit } if [[ -z \u0026#34;$1\u0026#34; ]]; then echo \u0026#34;Masukkan namamu!\u0026#34; usage fi for _ in {1..3}; do echo \u0026#34;[$_] Namaku $1\u0026#34; done $ ./sapa.sh Masukkan namamu! Usage: sapa.sh \u0026lt;nama\u0026gt; $ ./sapa.sh Fulan [1] Namaku Fulan [2] Namaku Fulan [3] Namaku Fulan Variabel $#, $@ dan $* $# Variabel $# digunakan untuk mengetahui jumlah parameter yang diberikan. Misalnya:\n$ coba.sh a b c d # maka nilai $# adalah 4 Ini bisa dimanfaatkan salahsatunya untuk melakukan validasi apakah user memberikan argumen atau tidak:\n#!/usr/env/bin bash if [[ $# -eq 0 ]]; then echo \u0026#34;Harap berikan argumen!\u0026#34; exit 1 fi echo \u0026#34;Jumlah argumen: $#\u0026#34; Maka saat dicoba:\n$ ./coba.sh Harap berikan argumen! $ ./coba.sh aa bb cc dd ee Jumlah argumen: 5 $@ dan $* Dua variabel ini digunakan untuk mengakses seluruh argumen yang diberikan.\nContoh 1 #!/usr/bin/env bash echo \u0026#34;Percobaan \\$@\u0026#34; echo \u0026#34;Arg: [ $@ ]\u0026#34; echo \u0026#34;Percobaan \\$*\u0026#34; echo \u0026#34;Arg: [ $* ]\u0026#34; $ ./coba.sh haha hehe hoho huhu Percobaan $@ Arg: [ haha hehe hoho huhu ] Percobaan $* Arg: [ haha hehe hoho huhu ] Pertanyaannya, jika outputnya sama, mengapa dibedakan? Pada contoh diatas, tidak akan ketara perbedaannya. Mari dilihat pada contoh berikutnya.\nContoh 2 #!/usr/bin/env bash printf \u0026#39;== %s ==========\\n\u0026#39; \u0026#34;Menggunakan \\$@\u0026#34; printf \u0026#39;arg: %s\\n\u0026#39; \u0026#34;$@\u0026#34; echo printf \u0026#39;== %s ==========\\n\u0026#39; \u0026#34;Menggunakan \\$*\u0026#34; printf \u0026#39;arg: %s\\n\u0026#39; \u0026#34;$*\u0026#34; $ ./coba.sh 11 22 33 44 == Menggunakan $@ ========== arg: 11 arg: 22 arg: 33 arg: 44 == Menggunakan $* ========== arg: 11 22 33 44 $ ./coba.sh \u0026#34;haha\u0026#34; \u0026#34;ha~ha~\u0026#34; \u0026#34;haa haa\u0026#34; \u0026#34;hue hue\u0026#34; \u0026#34;hoo hoo\u0026#34; == Menggunakan $@ ========== arg: haha arg: ha~ha~ arg: haa haa arg: hue hue arg: hoo hoo == Menggunakan $* ========== arg: haha ha~ha~ haa haa hue hue hoo hoo Maka:\nVariabel $@ akan expand dan masing-masingnya menjadi argumen. Variabel $* akan expand menjadi satu string utuh. Nah, untuk bisa memahami kesimpulannya, maka saya coba berikan contoh script sederhana berikut ini.\nContoh 3 #!/usr/bin/env bash # command file berfungsi untuk mengetahui jenis \u0026#34;file\u0026#34; # command tersebut mendukung multi argumen, file file1 file2 ... fileN printf \u0026#39;== %s ==========\\n\u0026#39; \u0026#34;Menggunakan \\$@\u0026#34; file -- \u0026#34;$@\u0026#34; printf \u0026#39;== %s ==========\\n\u0026#39; \u0026#34;Menggunakan \\$*\u0026#34; file -- \u0026#34;$*\u0026#34; # Membuat file file1 s/d file3, pembahasan brace expansion $ touch file{1..3} $ ./coba.sh file1 file2 file3 == Menggunakan $@ ========== file1: empty file2: empty file3: empty == Menggunakan $* ========== file1 file2 file3: cannot open `file1 file2 file3\u0026#39; (No such file or directory) Bisa diperhatikan, pada $@, sintaks file -- \u0026quot;$@\u0026quot;, input ./coba.sh file1 file2 file3 akan terexpand sesuai dengan masing-masing argumennya file -- \u0026quot;file1\u0026quot; \u0026quot;file2\u0026quot; \u0026quot;file3\u0026quot; dengan total argumen sebanyak 4.\nSedangkan pada $* input yang sama, akan terekspand menjadi file -- \u0026quot;file1 file2 file3\u0026quot;. Jika dipecah kembali, maka akan didapatkan total 2 argumen saja:\nArgumen 1: -- Argumen 2: file1 file2 file3 Sehingga, secara harfiah, file yang bernama “file1 file2 file3” memang tidak ada pada folder tersebut.\nSemoga bermanfaat, barakallahufiikum.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-arguments/","summary":"Pada artikel kali ini, saya akan membahas mengenai shell argumens, yaitu bagaimana agar kita dapat memasukkan parameter tertentu saat memanggil script yang telah kita tulis atau saat memanggul fungsi yang telah kita definisikan.\nParameter/argumen Mari kita lihat pada command cp berikut ini:\ncp -f file1 file2 Command diatas bisa diartikan dengan \u0026ldquo;menyalin secara paksa file1 sebagai file2\u0026rdquo;.\nPaksaan yang dimaksud adalah jika file2 sebelumnya telah ada, maka langsung menimpa file2 tersebut dengan file1tanpa memberitahu user terlebih dahulu.","title":"Belajar Bash Scripting: Arguments"},{"content":" Pada artikel ini saya akan menjelaskan seputar shell functions, bagaimana cara mendefinisikan suatu fungsi pada Bash shell yang itu merupakan seperangkat perintah yang disusun sedemikian rupa agar bisa digunakan kembali pada bagian lain suatu script.\nStruktur dasar Sebuah fungsi dapat didefinisikan dengan susunan sebagai berikut:\nnama_fungsi() { ... command1 command2 ... } # atau function nama_fungsi() { ... } Kedua bentuk diatas tidak memiliki perbedaan, namun sebagian ahli mengatakan bahwa bentuk kedua tidaklah portabel. Alias, tidak kompatibel dengan Bash shell versi lama.\nMemanggil fungsi Cara untuk memanggil fungsi tersebut adalah cukup dengan memanggil nama fungsi tersebut (tanpa kurung).\nhello_world() { echo \u0026#34;Hello, World!\u0026#34; } hello_world # Hello, World! Diantara kesalahan orang-orang yang baru pertama kali menulis shell script adalah memanggil fungsi shell dengan diakhiri tanda () sebagaimana pada sintaks keumuman bahsa pemrograman.\nfungsi() { ... } # salah fungsi() # benar fungsi Variabel global vs lokal Pada dasarnya, setiap variabel yang didefinisikan di dalam variabel merupakan variabel lokal secara asal. Namun, Anda bisa mendefinisikannya secara eksplisit dengan sintaks local.\nJika ada variabel global (yang sudah didefinisikan sebelum dan diluar fungsi) kemudian ada variabel dengan nama yang sama didefinisikan didalam fungsi tersebut (lokal), maka variabel lokal tersebut yang akan diutamakan.\nnama=\u0026#34;Alan\u0026#34; fungsi() { local nama=\u0026#34;Fulan\u0026#34; echo \u0026#34;Hello, ${nama}.\u0026#34; } fungsi # Hello, Fulan. echo \u0026#34;Hello, ${nama}.\u0026#34; # Hello, Alan. Argumen/parameter pada fungsi Argumen atau parameter pada shell bash direpresentasikan dengan variabel shell $1, $2, $3 dan seterusnya, menyesuaikan dengan posisi argumen tersebut. Penjelasan lebih terperinci ada pada artikel Belajar Bash Scripting: Shell Arguments.\nsalam() { echo \u0026#34;Ahlan wa sahlan, ${1}!\u0026#34; echo \u0026#34;Selamat datang, ${2}.\u0026#34; } salam Fulan Alan # Ahlan wa sahlan, Fulan! # Selamat datang, Alan. Menentukan nilai return pada fungsi Pada keumuman bahasa pemrograman, suatu fungsi dapat \u0026ldquo;mengembalikan\u0026rdquo; suatu nilai setelah dieksekusi. Itu bisa berupa string, integer, boolean atau yang lainnya.\nTerkadang pula, untuk menentukan nilai return tersebut perlu mendeklarasikan jenis data yang akan dikembalikan tersebut.\nHal ini tidak berlaku pada shell scripting, terutama pada shell Bash. Semua command yang mengeluarkan outputnya pada stdout, maka itu bisa dianggap sebagai nilai return.\ncpu_cores() { grep -c \u0026#39;^processor\u0026#39; /proc/cpuinfo } worker=$(( ( `cpu_cores` * 2 ) + 1 )) echo \u0026#34;Jumlah worker: $worker\u0026#34; # Jumlah worker: 9 Sintaks return Sintaks return fungsinya tidak sebagaimana pada keumuman bahasa pemrograman (yaitu menentukan nilai balik suatu fungsi), tetapi ini berfungsi untuk keluar dari suatu fungsi tanpa menghentikan eksekusi script.\nMisalnya, pada suatu fungsi terdapat pengkondisian seperti berikut ini:\nfungsi() { local file=\u0026#34;$1\u0026#34; if [[ -f \u0026#34;$file\u0026#34; ]]; then echo \u0026#34;File sudah ada\u0026#34; return fi if [[ ! -w \u0026#34;$file\u0026#34; ]]; then echo \u0026#34;Tidak dapat menulis file.\u0026#34; return 1 fi # Jika file belum ada ... ... ... } Nilai yang didefinisikan setelah sintaks return tersebut, adalah nilai exit. Ketentuannya adalah, jika nilai tersebut lebih dari nol, maka error terjadi.\nIni bisa dimanfaatkan untuk meniru nilai return boolean, seperti contoh berikut ini:\nfile_exists() { test -f \u0026#34;$1\u0026#34; || return 1 return } if file_exists \u0026#34;file.jpg\u0026#34;; then ... fi Tambahan, jika melihat penjelasan sintaks return dari help return, maka dijelaskan bahwa sintaks tersebut hanya bisa dieksekusi dari dalam suatu fungsi. Sehingga, ketika sintaks tersebut dijalankan diluar fungsi, maka akan ekluar eror:\nbash: return: can only `return\u0026#39; from a function or sourced script Semoga bermanfaat, Barakallahufiikum.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-functions/","summary":"Pada artikel ini saya akan menjelaskan seputar shell functions, bagaimana cara mendefinisikan suatu fungsi pada Bash shell yang itu merupakan seperangkat perintah yang disusun sedemikian rupa agar bisa digunakan kembali pada bagian lain suatu script.\nStruktur dasar Sebuah fungsi dapat didefinisikan dengan susunan sebagai berikut:\nnama_fungsi() { ... command1 command2 ... } # atau function nama_fungsi() { ... } Kedua bentuk diatas tidak memiliki perbedaan, namun sebagian ahli mengatakan bahwa bentuk kedua tidaklah portabel.","title":"Belajar Bash Scripting: Functions"},{"content":" Setelah mempelajari mengenai elemen-elemen dasar pada suatu script, kali ini saya akan menjelaskan bagaimana membuat file script.\nJika Anda ingin mempelajari ulang mengenai elemen-elemen yang dimaksud, bisa Anda pelajari melalui tautan-tautan dibawah ini:\nKonsep dasar Shell Variables Konsep dasar Shell Conditionals Konsep dasar Shell Loops Konsep dasar Shell Functions Pada dasarnya, shell script merupakan file yang berisi serangkaian instruksi shell yang disusun sedemikian rupa untuk tujuan tertentu.\nDiantara tujuan tersebut dapat berupa instruksi otomasi proses, CLI (command line interface) tool, program wrapper sebagai ekstensi suatu program lain yang sudah ada, dan semisalnya.\nStruktur Dasar Ekstensi file Pada umumnya, file script diberi akhiran .sh namun sebenarnya ini tidak wajib. Hanya saja ini merupakan praktik yang umum dilakukan.\nNamun, ini akan memudahkan user untuk bisa mengetahui bahwa suatu file adalah file script atau bukan, bisa dilihat dari ekstensi .sh-nya.\nShebang / Hashbang Suatu file script selalu diawali dengan yang namanya SHEBANG atau HASHBANG. Contohnya adalah seperti berikut ini:\n#!/usr/bin/bash Fungsi dari shebang ini adalah untuk memberitahu shell bahwa untuk menjalankan script tersebut, program yang digunakan adalah bash (atau yang lainnya).\nMaka, shebang ini ditentukan di baris paling pertama, diawali dengan karakter pagar dan pentung #!. Kemudian diikuti dengan path menuju file binary program/shell yang ingin ditulis scriptnya.\nMisalnya, jika hendak menulis script untuk Bourne Shell (sh), maka:\n#!/bin/sh atau Z Shell:\n#!/bin/zsh atau Python 3.10:\n#!/usr/bin/python3.10 atau awk:\n#!/usr/bin/awk -f dan sebagainya.\nBagaimana jika path untuk shell Bash (misalnya), lokasinya tidak menentu? Bisa jadi ada di /bin/bash atau /usr/bin/bash atau /usr/local/bin/bash ?\nPraktik yang disarankan adalah menggunakan program env, contoh:\n#!/usr/bin/env bash Dengan demikian, env akan mencari path yang valid untuk shell Bash tanpa harus menentukannya secara hard-coded.\nMemiliki izin eksekusi (executable) Suatu file script perlu memliki izin eksekusi (executable) agar bisa dieksekusi langsung tanpa harus memanggil shell yang terkait.\nchmod +x file.sh Jika tidak demikian, ketika hendak dieksekusi, maka shell akan mengeluarkan error \u0026ldquo;Permission denied\u0026rdquo;.\n$ ./script.sh bash: ./script.sh: Permission denied Atau, perlu memanggil program/shell yang akan digunakan terlebih dahulu sebelum mengeksekusi. Contohnya:\n$ bash script.sh # atau $ python script.py ... Contoh file script Script hello-world.sh:\n#!/usr/bin/env bash echo \u0026#34;Hello, World!\u0026#34; Script oraganize.sh, berfungsi untuk menata file berdasarkan ekstensi file:\n#!/usr/bin/env bash if [[ -z \u0026#34;$1\u0026#34; ]]; then echo \u0026#34;Penggunaan: $(basename $0) /path/to/dir\u0026#34; exit fi if [[ ! -d \u0026#34;$1\u0026#34; ]]; then echo \u0026#34;Direktori tidak valid\u0026#34; exit 1 fi find \u0026#34;$1\u0026#34; -maxdepth 1 -type f | while read file; do extension=${file##*.} new_folder=\u0026#34;${1%/}/${extension}\u0026#34; mkdir -p \u0026#34;$new_folder\u0026#34; \\ \u0026amp;\u0026amp; mv \u0026#34;$file\u0026#34; \u0026#34;$new_folder\u0026#34; done Semoga bermanfaat, barakallahufiikum.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-menulis-script/","summary":"Setelah mempelajari mengenai elemen-elemen dasar pada suatu script, kali ini saya akan menjelaskan bagaimana membuat file script.\nJika Anda ingin mempelajari ulang mengenai elemen-elemen yang dimaksud, bisa Anda pelajari melalui tautan-tautan dibawah ini:\nKonsep dasar Shell Variables Konsep dasar Shell Conditionals Konsep dasar Shell Loops Konsep dasar Shell Functions Pada dasarnya, shell script merupakan file yang berisi serangkaian instruksi shell yang disusun sedemikian rupa untuk tujuan tertentu.\nDiantara tujuan tersebut dapat berupa instruksi otomasi proses, CLI (command line interface) tool, program wrapper sebagai ekstensi suatu program lain yang sudah ada, dan semisalnya.","title":"Belajar Bash Scripting: Menulis Script"},{"content":" Ini adalah artikel ringkas yang membahas tentang cara untuk mencari tahu seluruh konfigurasi filter yang diatur oleh tiap akun email.\nPada dasarnya, perintah yang digunakan adalah:\nzmprov -l ga \u0026lt;nama akun\u0026gt; zimbraMailSieveScript Contoh output:\n# name user1@example.com zimbraMailSieveScript: require [\u0026#34;fileinto\u0026#34;, \u0026#34;copy\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;tag\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;variables\u0026#34;, \u0026#34;log\u0026#34;, \u0026#34;enotify\u0026#34;, \u0026#34;envelope\u0026#34;, \u0026#34;body\u0026#34;, \u0026#34;ereject\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;relational\u0026#34;, \u0026#34;comparator-i;ascii- numeric\u0026#34;]; # forward if anyof (address :all :contains :comparator \u0026#34;i;ascii-casemap\u0026#34; [\u0026#34;to\u0026#34;] \u0026#34;user1@example.com\u0026#34;) { redirect \u0026#34;user2@example.com\u0026#34;; stop; } Sehingga, untuk meng-query keseluruhan akun, bisa menggunakan loop atau xargs:\nzmprov -l gaa | xargs -n1 -I zmprov -l ga {} zimbraMailSieveScript # atau for account in $(zmprov -l gaa); do echo \u0026#34;$account\u0026#34; zmprov -l ga \u0026#34;$account\u0026#34; zimbraMailSieveScript done # atau zmprov -l gaa | while read account; do echo \u0026#34;$account\u0026#34; zmprov -l ga \u0026#34;$account\u0026#34; zimbraMailSieveScript done # atau while read account; do echo \u0026#34;$account\u0026#34; zmprov -l ga \u0026#34;$account\u0026#34; zimbraMailSieveScript done \u0026lt; \u0026lt;(zmprov -l gaa) Semoga bermanfaat, barakallahufiikum.\nReferensi: Steps to get filters of all accounts\n","permalink":"https://blog.annahri.com/posts/jurnal-zimbra-mencari-tahu-konfigurasi-filter-untuk-semua-akun/","summary":"Ini adalah artikel ringkas yang membahas tentang cara untuk mencari tahu seluruh konfigurasi filter yang diatur oleh tiap akun email.\nPada dasarnya, perintah yang digunakan adalah:\nzmprov -l ga \u0026lt;nama akun\u0026gt; zimbraMailSieveScript Contoh output:\n# name user1@example.com zimbraMailSieveScript: require [\u0026#34;fileinto\u0026#34;, \u0026#34;copy\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;tag\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;variables\u0026#34;, \u0026#34;log\u0026#34;, \u0026#34;enotify\u0026#34;, \u0026#34;envelope\u0026#34;, \u0026#34;body\u0026#34;, \u0026#34;ereject\u0026#34;, \u0026#34;reject\u0026#34;, \u0026#34;relational\u0026#34;, \u0026#34;comparator-i;ascii- numeric\u0026#34;]; # forward if anyof (address :all :contains :comparator \u0026#34;i;ascii-casemap\u0026#34; [\u0026#34;to\u0026#34;] \u0026#34;user1@example.com\u0026#34;) { redirect \u0026#34;user2@example.com\u0026#34;; stop; } Sehingga, untuk meng-query keseluruhan akun, bisa menggunakan loop atau xargs:","title":"Jurnal: Zimbra - Mencari Tahu Konfigurasi Filter Untuk Semua Akun"},{"content":" Artikel ini akan menjelaskan mengenai bagaimana cara untuk melakukan LOOP alias menjalankan sekumpulan command secara berulang-ulang dengan kondisi tertentu.\nFOR loop FOR loop pada shell Bash sifatnya sama seperti foreach pada keumuman bahasa pemrograman. Yaitu melakukan perulangan tanpa adanya counter, alias suatu perulangan tidaklah diketahui ke-berapa perulangan tersebut sedang terjadi. Atau sederhananya tidak ada indeks pada setiap perulangan.\nNamun dengan pengecualian jika FOR loop tersebut dideklarasikan menggunakan indeks. Akan tiba contohnya pada penjelasan di bawah.\nStruktur dasar Variabel $var dibawah ini adalah variabel yang berisi string-string yang dipisahkan dengan spasi.\n$ var=\u0026#34;a b c d\u0026#34; $ for VARIABEL in $var; do echo \u0026#34;Huruf $VARIABEL\u0026#34; done Huruf a Huruf b Huruf c Huruf d Sebenarnya, sintaks in VARIABEL adalah opsional. Jika sintaks tersebut tidak disebutkan, maka Bash akan mengambil dari Positional Argument.\n$ set -- 1 2 3 4 $ for angka; do echo \u0026#34;Angka ke-$angka\u0026#34; done Angka ke-1 Angka ke-2 Angka ke-3 Angka ke-4 Pada bagian in juga bisa diberikan suatu command yang outputnya akan digunakan untuk looping.\n$ for x in $(seq 10); do echo \u0026#34;Urutan ke $x\u0026#34; done Urutan ke 1 Urutan ke 2 ... Urutan ke 10 Model bahasa C (C-Style FOR loop) C-style loop sesuai dengan namanya, yaitu model FOR loop menggunakan model bahasa pemrograman C.\n$ for ((i = 0; i \u0026lt; 10; i++)); do echo \u0026#34;Angka $i\u0026#34; done Angka 0 Angka 1 Angka 2 ... Angka 9 WHILE loop Sama seperti keumuman bahasa pemrograman, WHILE loop ini akan terus diulang-ulang selama kondisi yang diujikan masih benar.\nWHILE loop ini memberikan fleksibilitas yang lebih daripada FOR loop. Ketika FOR loop hanya terbatas pada tiap yang argumen diberikan, WHILE loop bisa digunakan lebih dari itu.\nStruktur dasar Agak mirip secara struktur, yaitu dimulai dari while kondisi; do ...; done. Setiap loop pada bash, pasti ada sintaks do .. done.\nwhile [[ $x -lt 10 ]]; do command ... ((x++)) done Looping terus-menerus Karena sifat WHILE loop ini yang akan terus melakukan perulangan ketika kondisi yang diujikan bernilai benar, maka jika ia diberikan sintaks yang selalu bernilai benar seperti true misalnya, maka akan dihasilkan infinite loop.\nwhile true; do command ... if kondisi; then break fi done # atau while :; do command ... if kondisi; then break fi done Mengulang command terus-menerus Sebagaimana yang telah dicontohkan pada bagian sebelumnya (looping terus-menerus), sebenarnya sintaks true dan : merupakan sebuah command yang valid jika dijalankan pada shell secara langsung. Sehingga, WHILE loop bisa diletakkan padanya suatu command yang memiliki exit status. Jika exit status command tersebut adalah non-zero alias tidak bermasalah, maka loop akan berlanjut.\nwhile sleep 1; do command command done # atau while ssh -T HOST uptime; do sleep 1 done Membaca file, variabel atau output command dengan WHILE loop WHILE loop bisa dimanfaatkan untuk membaca baris tiap baris dari sebuah file atau output suatu command atau pipeline. Ini berguna jika kita hendak memproses tiap baris pada output tersebut.\nLoop dari pipe Melakukan piping semacam dibawah ini bisa dilakukan selama didalam loop tidak ada proses penyematan variabel. Karena, pipeline berlangsung didalam subshell sehingga, variabel yang sama, yang dipanggil dari dalam loop ini, adalah variabel yang berbeda. Namun, jika aktifitas loop tidak ada kegiatan mengisi isi variabel (yang sudah dideklarasi sebelum pipe ini) dan sebagainya, maka loop ini bisa dipakai.\nfind /dir -type f -name \u0026#39;pattern\u0026#39; | while read line; do file=$(basename \u0026#34;$line\u0026#34;) new_name=\u0026#34;new-${file}\u0026#34; echo \u0026#34;Renaming $file to $new_name\u0026#34; mv \u0026#34;$file\u0026#34; \u0026#34;$new_name\u0026#34; done Loop dengan input dari file, variabel atau process substitution Process Substitution memungkinkan kita untuk menginputkan serangkaian command (pipeline).\nDalam kasus loop ini, WHILE mendapat input tidak dari pipe sehingga semua yang terjadi didalamnya, tidak berada di dalam subshell. Yang artinya, semua penyematan variabel di dalam loop, akan benar-benar tersematkan.\nwhile read line; do ... done \u0026lt; file # atau while read line; do ... done \u0026lt;\u0026lt;\u0026lt; \u0026#34;$var\u0026#34; # atau while read line; do ... done \u0026lt; \u0026lt;(command) UNTIL loop UNTIL loop adalah kebalikan dari WHILE loop. Yaitu melakukan perulangan selama kondisi yang diberikan tetap bernilai salah.\nStruktur dasar Sama dengan WHILE loop, cukup menggantinya dengan UNTIL\nuntil kondisi; do command done # misal until [[ $# -eq 0 ]]; do : proses loop done Contoh penggunaan dalam script:\n# Loop akan exit jika input file yang diberikan adalah valid until [[ -f \u0026#34;$file\u0026#34; ]]; do read -p \u0026#34;Masukkan input file \u0026gt; \u0026#34; file done Sintaks break dan continue Sintaks break dan continue tidak terbatas hanya pada WHILE loop saja, tetapi juga bisa digunakan pada UNTIL dan FOR loop juga. Kedua sintaks ini berfungsi untuk mengatur alur suatu loop, baik untuk menghentikan loop (keluar dari loop) atau meloncati suatu iterasi.\nBreak Dalam infinite loop, perlu ada kondisi yang dimana dia akan membuat loop tersebut berhenti. Untuk dapat keluar dari loop, gunakan sintaks break. Contoh untuk ini sudah dijelaskan pada bagian WHILE loop sebelumnya. Atau misal pada kasus script interaktif seperti contoh berikut:\nwhile read -p \u0026#34;Masukkan angka 1-10 \u0026gt; \u0026#34; angka; do if [[ $angka -gt 10 || $angka -lt 1 || $angka =~ [^0-9]+ ]]; then echo \u0026#34;Input tidak valid!\u0026#34; else echo \u0026#34;Angka terpilih: $angka\u0026#34; break fi done Continue Sedangkan jika dalam suatu loop ada sebuah kondisi yang jika kondisi tersebut terpenuhi, maka perputaran saat itu diloncati, maka hal tersebut bisa dilakukan dengan sintaks continue.\nfor ((i = 1; i \u0026lt; 10; i++)); do if ((i % 2 != 0)); then continue fi ... done Loop non-standar Pipeline jika dirangkai sedemikian rupa juga akan bisa melakukan loop. Contohnya adalah gabungan dari seq atau Bash brace expansion yang dipipe kepada xargs seperti contoh berikut ini:\nseq 10 | xargs -n1 -I{} echo \u0026#34;Putaran ke-{}\u0026#34; # atau serupa dengan for i in {1..10}; do echo \u0026#34;Putaran ke-$i\u0026#34; done Mencari bilangan genap dari 1 sampai 100 :\necho {1..100} | xargs -n1 -I{} bash -c \u0026#39;if (( {} % 2 == 0 )); then echo {}; fi\u0026#39; Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-loop/","summary":"Artikel ini akan menjelaskan mengenai bagaimana cara untuk melakukan LOOP alias menjalankan sekumpulan command secara berulang-ulang dengan kondisi tertentu.\nFOR loop FOR loop pada shell Bash sifatnya sama seperti foreach pada keumuman bahasa pemrograman. Yaitu melakukan perulangan tanpa adanya counter, alias suatu perulangan tidaklah diketahui ke-berapa perulangan tersebut sedang terjadi. Atau sederhananya tidak ada indeks pada setiap perulangan.\nNamun dengan pengecualian jika FOR loop tersebut dideklarasikan menggunakan indeks. Akan tiba contohnya pada penjelasan di bawah.","title":"Belajar Bash Scripting: Loop"},{"content":" Pada artikel ini saya akan memberikan contoh script Bash dan Python yang berfungsi untuk menampilkan jumlah antrian email (mail queue) keluar pada Postfix. Ini berguna sebagai metrics yang bisa digunakan untuk alerting. Baik alerting manual maupun terintegrasi seperti ServerDensity, dan sebagainya.\nDasar Script Komponen utama utama untuk mengetahui mail queue adalah folder dimana queue tersebut singgah untuk sementara waktu. Untuk mengetahuinya, kita bisa memanggil command postconf -h queue_directory yang outputnya akan menunjukkan dimana direktori tersebut.\nContoh struktur dari folder queue tersebut adalah seperti ini:\nroot@postfix-relay-new:/var/spool/postfix# tree -d -L 1 -n . ├── active ├── bounce ├── corrupt ├── defer ├── deferred ├── dev ├── etc ├── flush ├── hold ├── incoming ├── lib ├── maildrop ├── pid ├── private ├── public ├── saved ├── trace └── usr 18 directories Folder-folder yang berisi queue email adalah active, corrupt, defer, deferred, hold dan incoming.\nContoh file queue yang ada pada folder deferred:\nroot@postfix-relay-new:/var/spool/postfix/deferred# find -type f ./E/EAB4426846 ./7/7C31723297 ./B/B2F962B543 ... ./2/28BD526F02 ./8/8B6742C09D ./5/548D72A868 Sehingga dari situ, kita cukup meracik command find sedemikian rupa sehingga command tersebut hanya akan menampilkan file-file queue saja pada direktori yang sudah ditunjuk oleh postconf -h queue_directory. Karena ciri file queue sifatnya seragam, maka bisa kita gunakan Regular Expression dibawah ini:\n[0-9A-F]+ Kemudian, jika sudah dapat outputnya, maka untuk masing-masing kondisi queue (active/defer, dsb) tinggal dihitung ada berapa baris yang pada path -nya terdapat substring active misalnya. Atau defer, dll. Dan ini bisa dilakukan dengan berbagai macam cara. Salah satu diantaranya adalah dengan grep.\ngrep -w -c \u0026#39;active\u0026#39; input # Dimana: # -w mencari kata utuh, bukan substring # -c jumlah temuan Dan selesai, intinya hanya itu saja.\nVersi Bash #1 Idenya adalah dengan menyimpan daftar queue pada suatu file temporer, kemudian untuk setiap state, kita panggil grep count untuk menemukan ada berapa kali keyword state tersebut ditemukan pada file temporer tersebut.\n#!/usr/bin/env bash readonly queue_dir=$(postconf -h queue_directory) readonly tmp_file=$(mktemp) states=(all active corrupt defer deferred hold incoming) get_count() { printf \u0026#39;%s: %d\\n\u0026#39; \u0026#34;$1\u0026#34; $(egrep -w -c \u0026#34;$2\u0026#34; \u0026#34;$tmp_file\u0026#34;) } main() { find \u0026#34;$queue_dir\u0026#34; -type f -regextype egrep -regex \u0026#39;.*/[0-9A-F]{5,}$\u0026#39; \u0026gt; \u0026#34;$tmp_file\u0026#34; for state in ${states[@]}; do search=\u0026#34;$state\u0026#34; [[ $state = all ]] \u0026amp;\u0026amp; search=\u0026#39;.*\u0026#39; get_count \u0026#34;$state\u0026#34; \u0026#34;$search\u0026#34; done rm -f \u0026#34;$tmp_file\u0026#34; } main Contoh output jika dijalankan:\nroot@postfix-relay-new:~/script# time bash script.sh all: 43 active: 0 corrupt: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.098s user\t0m0.026s sys\t0m0.015s Versi Bash #2 Melakukan loop untuk setiap entri queue yang ditemukan kemudian langsung menghitungnya dan menyimpannya pada array asosiatif. Tetapi ini memerlukan 2 kali loop. Yang pertama untuk menghitung jumlah, yang kedua untuk mengeluarkan output.\n#!/usr/bin/env bash readonly queue_dir=$(postconf -h queue_directory) declare -A count=([active]=0 [corrupt]=0 [defer]=0 [deferred]=0 [hold]=0 [incoming]=0) total=0 while read line; do state=$(cut -d\u0026#39;/\u0026#39; -f5 \u0026lt;\u0026lt;\u0026lt; \u0026#34;$line\u0026#34;) (( ++count[$state] )) (( ++total )) done \u0026lt; \u0026lt;(find \u0026#34;$queue_dir\u0026#34; -type f -regextype egrep -regex \u0026#39;.*/[0-9A-F]+$\u0026#39;) echo \u0026#34;all: $total\u0026#34; for i in ${!count[@]}; do printf \u0026#39;%s: %d\\n\u0026#39; $i ${count[$i]} done | sort Output:\nroot@postfix-relay-new:~/script# time bash script3.sh all: 43 active: 0 corrupt: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.133s user\t0m0.084s sys\t0m0.052s Versi Bash #3 (dengan AWK) Versi AWK ini merupakan versi paling cepat diantara versi script Bash sebelumnya. Karena shell tidak melakukan loop sama sekali, dan seluruh proses dilakukan oleh awk dalam sekali eksekusi. Sedangkan pada script sebelumnya (#2), setiap iterasi ada eksekusi eksternal tool cut yang berdampak pada durasi eksekusi (meskipun tidak terlalu signifikan).\nIde yang digunakan, sama dengan pada script bash versi kedua.\n#!/usr/bin/env bash find `postconf -h queue_dir` -type f -regextype egrep -regex \u0026#39;.*/[0-9A-F]{5,}$\u0026#39; \\ | awk -F\u0026#39;/\u0026#39; \u0026#39;BEGIN { count[\u0026#34;active\u0026#34;]=0; count[\u0026#34;corrupt\u0026#34;]=0; count[\u0026#34;defer\u0026#34;]=0; count[\u0026#34;deferred\u0026#34;]=0; count[\u0026#34;hold\u0026#34;]=0; count[\u0026#34;incoming\u0026#34;]=0 } { count[$5]++; total++ } END { print \u0026#34;all:\u0026#34;, total; for (n in count) print n\u0026#34;:\u0026#34;, count[n] | \u0026#34;sort\u0026#34; }\u0026#39; Agar mempermudah memahami sintaks awk panjang tersebut, berikut ini versi baris per baris:\nBEGIN { count[\u0026#34;active\u0026#34;]=0 count[\u0026#34;corrupt\u0026#34;]=0 count[\u0026#34;defer\u0026#34;]=0 count[\u0026#34;deferred\u0026#34;]=0 count[\u0026#34;hold\u0026#34;]=0 count[\u0026#34;incoming\u0026#34;]=0 } { count[$5]++ total++ } END { print \u0026#34;all:\u0026#34;, total for (n in count) print n\u0026#34;:\u0026#34;, count[n] | \u0026#34;sort\u0026#34; } Output:\nroot@postfix-relay-new:~/script# time bash wawk.sh all: 43 active: 0 corrupt: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.083s user\t0m0.011s sys\t0m0.011s Versi Python Script versi Python ini menggunakan ide yang sama pada script bash pertama.\nimport os from subprocess import check_output def get_list(): queue_dir = check_output([\u0026#39;postconf\u0026#39;,\u0026#39;-h\u0026#39;,\u0026#39;queue_directory\u0026#39;]).decode(\u0026#39;utf-8\u0026#39;).rstrip() command_string = \u0026#39;find \u0026#39; + queue_dir + \u0026#39; -type f -regextype egrep -regex .*/[0-9A-F]+$\u0026#39; return check_output(command_string.split()).decode(\u0026#39;utf-8\u0026#39;).rstrip().split(\u0026#39;\\n\u0026#39;) def get_count(string, search, list): n = sum(search in entry for entry in list) print(f\u0026#39;{string}: {n}\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: result = get_list() states = [\u0026#39;all\u0026#39;, \u0026#39;active\u0026#39;, \u0026#39;corrupt\u0026#39;, \u0026#39;defer\u0026#39;, \u0026#39;deferred\u0026#39;, \u0026#39;hold\u0026#39;, \u0026#39;incoming\u0026#39;] for state in states: search = state + \u0026#39;/\u0026#39; if state != \u0026#39;all\u0026#39; else \u0026#39;\u0026#39; get_count(state, search, result) Contoh output jika dijalankan:\nroot@postfix-relay-new:~/script# time python3 mqueue.py all: 43 active: 0 corrupted: 0 defer: 28 deferred: 15 hold: 0 incoming: 0 real\t0m0.076s user\t0m0.055s sys\t0m0.011s Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/jurnal-script-rincian-mail-queue-postfix/","summary":"Pada artikel ini saya akan memberikan contoh script Bash dan Python yang berfungsi untuk menampilkan jumlah antrian email (mail queue) keluar pada Postfix. Ini berguna sebagai metrics yang bisa digunakan untuk alerting. Baik alerting manual maupun terintegrasi seperti ServerDensity, dan sebagainya.\nDasar Script Komponen utama utama untuk mengetahui mail queue adalah folder dimana queue tersebut singgah untuk sementara waktu. Untuk mengetahuinya, kita bisa memanggil command postconf -h queue_directory yang outputnya akan menunjukkan dimana direktori tersebut.","title":"Jurnal: Script Rincian Mail Queue Postfix"},{"content":" Pada artikel ini, saya akan menjelaskan bagaimana cara membuat variabel, array, dan lain-lain yang berkaitan, pada shell Bash.\nSeperti yang sudah pernah dibahas pada artikel Belajar Bash Scripting lain, bahwa tentunya Bash Scripting yang dibahas ini tidaklah POSIX-compliant atau istilahnya Bashism.\nAturan penamaan Dalam membuat variabel atau array, ketentuan dalam pemberian nama adalah sebagai berikut:\nTidak diawali dengan angka. Tidak mengandung tanda pentung, tanda @, tanda pagar # dan asterisk (*). Variabel dengan huruf kapital seluruhnya, dikhususkan untuk variabel internal shell dan varibel environment. Contoh:\n1variabel # salah !variabel # salah @variabel # salah vari*abel # salah #variabel # salah vari#abel # salah vari!abel # salah vari@abel # salah SHELL # sudah digunakan sebagai environment variable HOSTNAME # sudah digunakan sebagai environment variable REPLY # sudah digunakan dalam BASH internal variable variabel # benar Variabel # benar vAriabel # benar vari_abel # benar _variabel # benar vari4bel # benar variabel1 # benar Variabel Membuat variabel Pada Bash shell, variabel bisa dibuat dengan cara seperti ini:\n# Tanpa petik var=string # Petik var=\u0026#34;string\u0026#34; # Petik tunggal var=\u0026#39;string\u0026#39; Perbedaan mengenai penggunaan tanda petik dan petik tunggal akan dijelaskan nanti.\nPerlu diperhatikan bahwa untuk membuat variabel, tidak boleh ada spasi diantara tanda =, misalnya:\n# Salah var = \u0026#34;string\u0026#34; var= \u0026#34;string\u0026#34; var =\u0026#34;string\u0026#34; Melihat isi variabel Isi variabel bisa dilihat dengan command echo atau printf:\n$ var=\u0026#34;Bismillah\u0026#34; $ echo \u0026#34;$var\u0026#34; Bismillah $ printf \u0026#39;%s\\n\u0026#39; \u0026#34;$var\u0026#34; Bismillah Mengisi variabel dari output suatu command Suatu variabel bisa diisi dengan output dari suatu command tertentu dengan menggunakan 2 cara:\nMenggunakan backticks `\u0026hellip;` Menggunakan command substitution $(...) Contoh:\nvar=`uname -r` var=$(uname -r) Cara kedua lebih disarankan karena 1) backticks sudah dianggap telah deprecated (ditinggalkan), 2) command substitution memungkinkan untuk digunakan secara berlapis. Misal:\nvar=$(ls -1 $(pwd)) Menambah isi variabel (append) Menambah isi variabel (yang berupa string) bisa dilakukan seperti membuat variabel tersebut namun tidak sekedar dengan tanda = saja, tetapi dengan +=, contoh:\n$ var=Hello $ echo \u0026#34;$var\u0026#34; Hello $ var+=\u0026#34;, World!\u0026#34; $ echo \u0026#34;$var\u0026#34; Hello, World! Kalkulasi aritmatis pada variabel (integer) Membuat variabel berupa hasil kalkulasi 2 bilangan bulat (atau lebih), bisa dilakukan dengan dua tanda kurung $((...))\n$ bil1=5 $ bil2=9 $ hasil=$((bil1 + bil2)) $ echo $hasil 14 $ kali=$((bil1 * bil2)) $ echo $kali 45 Variabel readonly Variabel readonly adalah variabel yang tidak bisa berubah setelah ditetapkan isinya, sama dengan konsep variabel konstan pada keumuman bahasa pemrograman.\n# cara 1 $ readonly var=string # cara 2 $ declare -r var=string $ var=strong bash: var: readonly variable Variabel lokal Variabel lokal adalah variabel yang ruang lingkupnya hanya pada suatu fungsi saja. Ketika dipanggil diluar fungsi tersebut, maka variabel yang dipanggil tersebut adalah variabel yang berbeda.\n$ var=xyz $ fungsi() { local var=abc # atau declare var=abc echo \u0026#34;$var\u0026#34; } $ echo \u0026#34;$var\u0026#34; xyz $ fungsi abc Membuat variabel dengan printf Command printf adalah salah satu tool builtin pada shell Bash. Selain berfungsi seperti echo, printf juga bisa digunakan untuk menetapkan suatu variabel.\n$ printf -v var \u0026#39;%s\\n\u0026#39; string $ echo \u0026#34;$var\u0026#34; string Membuat variabel berdasarkan input pengguna Yang dimaksud disini adalah membuat variabel dengan cara interaktif, yaitu membutuhkan inputan dari pengguna shell. Seperti \u0026ldquo;Siapa namamu?\u0026rdquo;, kemudian pengguna mengisikan namanya.\n$ read -r -p \u0026#34;Siapa namamu? \u0026#34; nama Siapa namamu? Fulan bin Fulan $ echo \u0026#34;Namaku: $nama\u0026#34; Namaku: Fulan bin Fulan Flag -r diatas berfungsi untuk menghindari backslash dari melakukan escaping karakter apapun. Sedangkan -p berfungsi untuk mem-print serangkaian kata yang sudah ditentukan sebelum melakukan read. Ini guna menghemat dari penggunaan echo sebelum read.\nKasus penggunaan tool read ini diantaranya adalah seperti melakukan konfirmasi Yes/No sebelum menjalankan command tertentu; atau membuat script yang interaktif, dan sebagainya.\nArray Diantara shell-shell yang ada, diantaranya ada yang mendukung array dan ada yang tidak. Bash adalah salah satu yang mendukung array. Jenis array yang bisa dibuat pada shell bash adalah Associative Array dan Indexed Array\nArray terindeks (indexed array) Yang dimaksud dengan indexed array adalah array yang tiap anggotanya memiliki nomor indeks masing-masing yang dimulai dari nol (zero indexed). Cara membuatnya adalah seperti berikut:\n# cara 1 array=(satu dua tiga) # cara 2 declare -a array=(satu dua tiga) Array asosiatif (associative array) Associative array, adalah jenis array yang memiliki key dan value. Cara membuat:\n$ declare -A array=([nama]=Fulan [kota]=Surabaya [pendidikan]=S1) $ array[status]=\u0026#34;Lajang\u0026#34; $ array[pekerjaan]=\u0026#34;Swasta\u0026#34; Melihat isi array Untuk melihat seluruh isi array:\nIndexed array $ echo \u0026#34;${array[@]}\u0026#34; satu dua tiga Untuk mengakses salah satu anggota array:\n$ echo \u0026#34;${array[1]}\u0026#34; dua Associative array Hampir sama dengan array terindeks, untuk melihat value tiap anggota array asosiatif:\n$ echo \u0026#34;${array[@]}\u0026#34; Fulan Surabaya S1 Lajang Swasta Untuk melihat seluruh key dari tiap anggota array:\n$ echo \u0026#34;${!array[@]}\u0026#34; nama kota pendidikan status pekerjaan Untuk melihat value dari key tertentu:\n$ echo \u0026#34;${array[status]}\u0026#34; Lajang Mengakses array menggunakan loop Mengakses array menggunakan loop memungkinkan untuk melakukan sesuatu terhadap tiap-tiap isi array, baik itu array asosiatif atau terindeks.\n# _Indexed_ array $ arr=(satu dua tiga empat) $ for angka in ${arr[@]}; do echo \u0026#34;Putaran ke-$angka\u0026#34;; done Putaran ke-satu Putaran ke-dua Putaran ke-tiga Putaran ke-empat # Associative array $ declare -A arr=([nama]=Alan [kota]=Surabaya [asal]=Jakarta) $ for key in ${!arr[@]}; do echo \u0026#34;Data $key =\u0026gt; ${arr[$key]}\u0026#34;; done Data nama =\u0026gt; Alan Data kota =\u0026gt; Surabaya Data asal =\u0026gt; Jakarta Menambah isi array Cara menambah isi array adalah seperti berikut:\n$ array+=(empat lima) $ echo \u0026#34;${array[@]}\u0026#34; satu dua tiga empat lima # Untuk array asosiatif juga sama $ array+=([key]=value [key2]=value2) Mengubah string menjadi array $ var=\u0026#34;satu dua tiga empat lima\u0026#34; $ array=( $var ) # atau $ declare -a array \u0026lt;\u0026lt;\u0026lt; $var Penjelasan mengenai \u0026lt;\u0026lt;\u0026lt; ada pada artikel mendatang, insyaAllah.\nMenkonversi file yang berisi list menjadi array Jika ada suatu file yang berisi suatu list (bisa berupa daftar string, dsb) dan hendak dikonversi menjadi array, maka bisa menggunakan mapfile:\n$ cat file aaaa bbbb cccc dddd $ mapfile list \u0026lt; file $ echo ${list[3]} dddd Kasus penggunaan array Pada sebuah script, menentukan sekumpulan options dari suatu command tertentu. Misalnya, script tersebut menggunakan rsync dan ada sekumpulan options dan flag yang sudah ditentukan untuk setiap panggilannya.\n#!/usr/bin/env bash rsync_options=(--archive --append --bwlimit=512k --progress ...) rsync() { rsync ${rsync_options[@]} .... } Referensi:\nhttps://www.geeksforgeeks.org/bash-script-define-bash-variables-and-its-types https://www.shell-tips.com/bash/math-arithmetic-calculation Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-variabel/","summary":"Pada artikel ini, saya akan menjelaskan bagaimana cara membuat variabel, array, dan lain-lain yang berkaitan, pada shell Bash.\nSeperti yang sudah pernah dibahas pada artikel Belajar Bash Scripting lain, bahwa tentunya Bash Scripting yang dibahas ini tidaklah POSIX-compliant atau istilahnya Bashism.\nAturan penamaan Dalam membuat variabel atau array, ketentuan dalam pemberian nama adalah sebagai berikut:\nTidak diawali dengan angka. Tidak mengandung tanda pentung, tanda @, tanda pagar # dan asterisk (*).","title":"Belajar Bash Scripting: Variabel (Update)"},{"content":" Pada artikel ini saya akan menjelaskan mengenai bagaimana cara melakukan macam-macam kondisional pada Bash scripting. Dan karena ini adalah seri khusus shell Bash, maka tentunya tidak POSIX-compliant.\nKondisional IF Struktur dasar Struktur dasar kondisional if dalam Bash scripting hampir sama dengan keumuman bahasa pemrograman, yaitu seperti dibawah ini:\nif kondisi; then command command ... fi # atau if kondisi then command command ... fi Kondisi yang disebutkan diatas bisa berupa ekspresi perbandingan seperti contoh berikut:\nif [[ $var == xyz ]]; then command command fi # atau if test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34;; then command command fi Atau, bisa berupa command tertentu seperti:\n# Jika command1 sukses maka jalankan command2 dan seterusnya if command1; then command2 command3 ... fi # Contoh # Jika variabel $string mengandung substring xyz, maka jalankan command1 if grep -q \u0026#39;xyz\u0026#39; \u0026lt;\u0026lt;\u0026lt; \u0026#34;$string\u0026#34;; then command1 fi Cara kerja Kondisional if akan menjalankan command di dalam blok jika kondisi yang diujikan memiliki exit status nol. Kedua contoh diatas ( sintaks [[ ... ]] atau test dan grep -q ) sebenarnya sama saja. Dalam artian bahwa sintaks [[ ... ]] sesungguhnya adalah command biasa yang bisa dijalankan diluar blok if. Bisa dicoba sendiri pada sesi shell seperti dibawah ini:\n[[ $var == \u0026#34;xyz\u0026#34; ]] \u0026amp;\u0026amp; echo true test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34; \u0026amp;\u0026amp; echo true Maka, jika variabel $var sama dengan string xyz, maka terminal akan mengeluarkan output \u0026ldquo;true\u0026rdquo;\nannahri@asus-zorin:/tmp$ var=xyz annahri@asus-zorin:/tmp$ [[ $var == \u0026#34;xyz\u0026#34; ]] \u0026amp;\u0026amp; echo true true annahri@asus-zorin:/tmp$ test \u0026#34;$var\u0026#34; == \u0026#34;xyz\u0026#34; \u0026amp;\u0026amp; echo true true Ekspresi kondisional / Conditional expression Salah satu contoh ekspresi kondisional adalah seperti yang sudah dijelaskan sebelumnya, yaitu [[ $var == \u0026quot;xyz\u0026quot; ]] yang itu merupakan bentuk dari operator string.\nDisini saya hanya akan menjelaskan beberapa contoh ekspresi yang sering digunakan. Untuk lebih lengkapnya, bisa dibaca sendiri via command help test.\nannahri@asus-zorin:/tmp$ help test test: test [expr] Evaluate conditional expression. Exits with a status of 0 (true) or 1 (false) depending on the evaluation of EXPR. Expressions may be unary or binary. Unary expressions are often used to examine the status of a file. There are string operators and numeric comparison operators as well. ............. Operator file Operator file berfungsi untuk mencari tahu status suatu file. Apakah file tersebut ada, apakah file tersebut adalah suatu direktori, dan lain-lain.\n# Jika $file adalah file reguler if [[ -f $file ]]; then command fi # Jika $file adalah direktori if [[ -d $file ]]; then command fi # atau if test -d \u0026#34;$file\u0026#34;; then command fi Operator string Digunakan untuk melakukan perbandingan suatu variabel terhadap variabel lain atau string literal. Seperti yang sudah dijelaskan pada contoh awal misalnya.\nif [[ $string == \u0026#34;asdf\u0026#34; ]]; then command fi # atau negasinya if [[ $string != \u0026#34;asdf\u0026#34; ]]; then command fi # Jika $string kosong alias unset if [[ -z $string ]]; then command fi # Jika $string tidak kosong alias memiliki nilai if [[ -n $string ]]; then command fi Operator aritmatik Sesuai dengan judulnya, maka operator ini berfungsi untuk melakukan perbandingan aritmatis.\n# Jika $var sama dengan 10 if [[ $var -eq 10 ]]; then command fi # Jika $var tidak sama dengan 10 if [[ $var -ne 10 ]]; then command fi # Jika $var lebih besar dari 10 if [[ $var -gt 10 ]]; then command fi # Jika $var lebih besar atau sama dengan 10 if [[ $var -ge 10 ]]; then command fi # Jika $var lebih kecil dari 10 if [[ $var -lt 10 ]]; then command fi # Jika $var lebih kecil atau sama dengan 10 if [[ $var -le 10 ]]; then command fi Kondisi ganda (Operator AND dan OR) Melakukan evaluasi lebih dari satu kondisi dapat dilakukan dengan operator \u0026amp;\u0026amp; (AND) dan operator || (OR). Contoh penggunaannya adalah sebagai berikut:\n# Jika $val lebih besar dari 10 dan lebih kecil dari 20 if [[ $val -gt 10 \u0026amp;\u0026amp; $val -lt 20 ]]; then command fi # Jika $string tidak kosong dan $string tidak bernilai \u0026#34;xyz\u0026#34; if [[ -n $string \u0026amp;\u0026amp; $string != \u0026#34;xyz\u0026#34; ]]; then command fi # Jika $string tidak kosong atau $val lebih dari nol if [[ -n $string || $val -lt 0 ]]; then command fi Tidak terbatas hanya pada perbandingan variabel, namun operator AND dan OR juga bisa digunakan untuk mengevaluasi 2 command atau lebih.\nBiasanya ini digunakan untuk melakukan perintah yang memerlukan prekondisi dari perintah lain. Seperti memastikan suatu file berhasil dibuat terlebih dahulu sebelum melakukan command setelahnya.\n# Jika path /a/b/c berhasil dibuat dan jika file /a/b/c/d berhasil dibuat if mkdir -p /a/b/c \u0026amp;\u0026amp; touch /a/b/c/d; then command fi Negasi Untuk melakukan evaluasi yang sebaliknya, maka cukup untuk menambahkan sintaks ! sebelum memulai ekspresi atau sebelum [[ ... ]]. Contoh:\n# Jika $file tidak ada, alias kebalikan dari `-f` if [[ ! -f $file ]]; then command fi Beda penempatan operator negasi, juga berbeda pula dampaknya. Jika negasi ditaruh sebelum ekspresi, maka tiap-tiap ekspresi yang berada di konteks yang sama (berada pada satu kurung siku [[ ... ]]) bisa diberlakukan negasi masing-masing. Namun, jika tanda negasi ditaruh diluar seperti ! [[ ... ]] maka negasi diberlakukan setelah seluruh ekspresi yang ada didalamnya dievaluasi.\n# Masing-masing if [[ ! -f $file || ! -d $dir ]]; then command fi # Keseluruhan if ! [[ -z $string || -f $file ]]; then command fi IF berlapis/nested Kondisional if tentu saja bisa dilakukan secara berlapis alias nested.\nif konsisi 1; then command if kondisi 2; then command ... fi fi Bentuk IF ELSE Kondisional IF ELSE jika ekspresi yang dievaluasi tidak terpenuhi maka ELSE akan dijalankan\n# Jika kondisi 1 terpenuhi maka command1 akan dijalankan, jika tidak maka command2 yang akan dijalankan if kondisi 1; then command1 else command2 fi bentuk IF ELSE IF Kondisional IF ELSE IF merupakan bentuk evaluasi ekspresi yang berkelanjutan tetapi perintah-perintah yang ada di dalam kondisi tersebut yang akan dijalankan, alias tidak akan menjalankan 2 kondisi secara bersamaan.\n# Jika kondisi 1 terpenuhi maka command1 dijalankan, jika tidak, # maka jika kondisi 2 terpenuhi, maka command2 akan dijalankan, namun jika tidak # maka jika kondisi 3 terpenuhi maka command3 akan dijalankan # tetapi jika seluruh kondisi tidak terpenuhi, maka command4 akan dijalankan if kondisi 1; then command1 elif kondisi 2; then command2 elif kondisi 3; then command3 else command4 fi Pada skenario diatas, jika variabel yang dievaluasi adalah variabel yang sama dan hendak mengevaluasi atas nilai-nilai tertentu, maka kondisional CASE-lah yang lebih cocok untuk digunakan. Contohnya sebagai berikut:\nif [[ $string == \u0026#34;a\u0026#34; ]]; then command1 elif [[ $string == \u0026#34;b\u0026#34; ]]; then command2 elif [[ $string == \u0026#34;c\u0026#34; ]]; then command3 . . . elif [[ $string == \u0026#34;z\u0026#34; ]]; then commandX else commandZ fi Bisa dilihat pada contoh diatas bahwa akan banyak pengulangan yang sebetulnya tidak perlu jika menggunakan kondisional CASE.\nKondisional CASE Kondisional CASE digunakan untuk melakukan evaluasi terhadap suatu variabel atau output command tertentu seperti pada contoh sebelumnya. Evaluasi yang dilakukan adalah ekspresi apakah variabel tersebut bernilai sekian atau sekian.\nStruktur dasar Kondisional CASE bisa memiliki beberapa bentuk/model dan merupakan preferensi masing-masing individu, tidak ada benar/salah.\nTetapi pada dasarnya, kondisional CASE diawali dengan case VARIABEL in kemudian diikuti dengan kondisi-kondisi. Tiap kondisi dibuka dengan PATTERN) (perhatikan tanda tutup kurung di akhir) dan ditutup dengan tanda ;;. Dan diakhiri dengan esac.\nBentuk yang umum adalah seperti ini:\n# Jika $string bernilai a, maka command1 dijalankan # Jika $string bernilai b, maka command2 dijalankan # Jika $string bernilai c, maka command3 dijalankan # namun jika tidak seluruhnya, maka commandZ akan dijalankan case \u0026#34;$string\u0026#34; in a) command1 ;; b) command2 ;; c) command3 ;; *) commandZ ;; esac Ada juga yang suka menulis blok CASE seperti ini, jika command untuk tiap kondisi tidaklah panjang.\ncase \u0026#34;$string\u0026#34; in a) command1 ;; b) command2 ;; c) command3 ;; *) commandZ ;; esac Operator OR Satu kondisi dalam CASE bisa diberi operator OR, contoh:\ncase \u0026#34;$string\u0026#34; in a|b) command1 ;; c|d) command2 ;; *) commandZ ;; esac Operator Wildcard * Operator wildcard * digunakan untuk mewakili satu atau lebih karakter. Contoh:\ncase \u0026#34;$string\u0026#34; in # Jika diawali dengan a a*) command1 ;; # Jika diawali dengan b dan diakhiri dengan c b*c) command3 ;; # Jika diakhiri dengan z *z) command4 ;; # Jika seluruh pattern tidak cocok *) commandZ ;; esac Perlu diperhatikan bahwa penempatan kondisi CASE sangat penting. Jika suatu kondisi/pattern yang bersifat lebih umum diletakkan lebih awal daripada yang lebih khusus, maka kondisi yang lebih khusus tersebut tidak akan pernah terevaluasi. Contoh:\n# Pola a*z sudah terwakili dengan pola sebelumnya (a*) # sehingga tidak akan terevaluasi. case \u0026#34;$string\u0026#34; in a*) command1 ;; a*z) command2 ;; esac Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/belajar-bash-scripting-conditional/","summary":"Pada artikel ini saya akan menjelaskan mengenai bagaimana cara melakukan macam-macam kondisional pada Bash scripting. Dan karena ini adalah seri khusus shell Bash, maka tentunya tidak POSIX-compliant.\nKondisional IF Struktur dasar Struktur dasar kondisional if dalam Bash scripting hampir sama dengan keumuman bahasa pemrograman, yaitu seperti dibawah ini:\nif kondisi; then command command ... fi # atau if kondisi then command command ... fi Kondisi yang disebutkan diatas bisa berupa ekspresi perbandingan seperti contoh berikut:","title":"Belajar Bash Scripting: Conditional"},{"content":" Sekedar dokumentasi dari permasalahan yang pernah saya jumpai. Terkadang dari sisi aplikasi tidak siap untuk dipublikasi secara HTTPS karena di dalam source code-nya masih ter-hardcoded beberapa resource eksternal menggunakan protokol HTTP.\nHal ini membuat kebanyakan web browser mengeluh dan enggan untuk memuat resource yang dipanggil dari protokol HTTP tadi.\nMaka solusinya ada 2:\nEdit source code-nya, ganti semua kode yang memanggil resource dari HTTP menjadi HTTPS. Dari sisi Reverse-Proxy, tinggal tambahkan header berikut: add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; Kali ini saya akan membahas solusi untuk Reverse-Proxy Nginx\nContoh konfigurasi server block dan penempatan header :\nserver { listen 443 ssl http2; server_name namawebsite.tld; root /var/www/public_html; ... konfigurasi ssl ... add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; \u0026lt;-- Taruh disini, di dalam server block dan diluar block location location / { ... konfigurasi ... } } Semoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/jurnal-nginx-reverse-proxy-mixed-content/","summary":"Sekedar dokumentasi dari permasalahan yang pernah saya jumpai. Terkadang dari sisi aplikasi tidak siap untuk dipublikasi secara HTTPS karena di dalam source code-nya masih ter-hardcoded beberapa resource eksternal menggunakan protokol HTTP.\nHal ini membuat kebanyakan web browser mengeluh dan enggan untuk memuat resource yang dipanggil dari protokol HTTP tadi.\nMaka solusinya ada 2:\nEdit source code-nya, ganti semua kode yang memanggil resource dari HTTP menjadi HTTPS. Dari sisi Reverse-Proxy, tinggal tambahkan header berikut: add_header \u0026#39;Content-Security-Policy\u0026#39; \u0026#39;upgrade-insecure-requests\u0026#39;; Kali ini saya akan membahas solusi untuk Reverse-Proxy Nginx","title":"Jurnal: Membenahi kendala mixed-content pada Nginx Reverse-Proxy"},{"content":" Saya akan menjelaskan beberapa tips dan trik dalam menggunakan shell bash yang biasa saya gunakan sehari-hari.\nReverse Search Sebagian orang biasa menggunakan history untuk melihat/mencari command-command sebelumnya yang sudah pernah diinputkan. Atau bahkan menggunakan arrow key atas untuk mencari command yang diinginkan.\nSebenarnya hampir kebanyakan shell memiliki fitur reverse search. Sesuai namanya, fitur ini bisa melakukan pencarian terhadap command yang sebelumya pernah diinputkan.\nBagaimana caranya? Cukup menekan CTRL+R pada terminal. Dan ketikkan kata kunci untuk command yang sedang dicari.\n(reverse-i-search)`apt\u0026#39;: sudo apt install hugo ^ ^ | |- history terakhir yang paling relevan |- keyword Sintaks Spesial !!, !$ dan !n Sintaks !! Pada bash shell (atau shell yang lain juga, mungkin) menrujuk kepada command terakhir yang diinputkan.\nJadi, jika sebelumnya kita menginputkan, misal, perintah echo abc. Lalu pada input berikutnya jika kita memasukkan !! maka, shell akan mengeksekusi kembali perintah echo abc.\nuser@host:~$ echo abc abc user@host:~$ !! echo abc \u0026lt;--- terminal tidak benar-benar mengeluarkan output ini, hanya sebagai penjelasan ekspansi shell saja abc Ini sangat berguna ketika kita lupa hendak menambahkan sudo pada suatu command yang panjang. Maka, pada input berikutnya, kita tinggal ketikkan sudo !! tanpa perlu mengetik ulang command sebelumnya.\nuser@host:~$ apt install -y package1 package2 package3 package4 package5 E: Could not open lock file /var/lib/dpkg/lock-frontend - open (13: Permission denied) E: Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), are you root? user@host:~$ sudo !! sudo apt install -y package1 package2 package3 package4 package5 ... Sintaks !$ Sintaks ini merujuk pada positional argument pada command terakhir. Sama seperti contoh sebelumnya, jika echo abc maka ekspansi dari !$ adalah abc.\nKasus penggunaan sintaks ini biasanya saat melakukan editing file. Seperti di bawah ini:\nuser@host:~$ cat /path/panjang/menuju/file isi file user@host:~$ vim !$ vim /path/panjang/menuju/file ... Jadi tidak perlu lagi mengetik ulang path panjang file yang dituju, tapi cukup gunakan sintaks !$ saja.\nSintaks !n Huruf n merujuk kepada angka pada history shell. Jika kita menjalankan perintah history maka tiap-tiap baris history terdapat angka disebelahnya (kecual jika konfigurasi untuk history sudah tidak default). Nah, dengan menggunakan !n maka shell akan mengulangi command yang sama sesuai dengan nomor yang tertera.\nContoh:\nuser@host:~$ history 1 ll 2 ls 3 lsblk 4 history user@host:~$ !1 ll total 20 drwxr-xr-x 1 user user 110 Nov 5 07:23 ./ drwxr-xr-x 1 root root 42 Nov 5 07:22 ../ -rw-r--r-- 1 user user 220 Nov 5 07:22 .bash_logout -rw-r--r-- 1 user user 3771 Nov 5 07:22 .bashrc drwx------ 1 user user 0 Nov 5 07:23 .cache/ drwxr-xr-x 1 user user 40 Nov 5 07:22 .config/ -rw-r--r-- 1 user user 5 Nov 5 07:22 .hidden -rw-r--r-- 1 user user 87 Nov 5 07:22 .inputrc -rw-r--r-- 1 user user 807 Nov 5 07:22 .profile Pintasan Clear Screen clear Command clear digunakan untuk membersihkan sesi layar shell. Agar lebih cepat, cukup tekan kombinasi tombol CTRL+L.\nBersambung, insyaAllah\n","permalink":"https://blog.annahri.com/posts/trik-bash-shell-1/","summary":"Saya akan menjelaskan beberapa tips dan trik dalam menggunakan shell bash yang biasa saya gunakan sehari-hari.\nReverse Search Sebagian orang biasa menggunakan history untuk melihat/mencari command-command sebelumnya yang sudah pernah diinputkan. Atau bahkan menggunakan arrow key atas untuk mencari command yang diinginkan.\nSebenarnya hampir kebanyakan shell memiliki fitur reverse search. Sesuai namanya, fitur ini bisa melakukan pencarian terhadap command yang sebelumya pernah diinputkan.\nBagaimana caranya? Cukup menekan CTRL+R pada terminal.","title":"Trik Bash Shell #1"},{"content":" Saya akan menjelaskan cara mudah untuk resize disk suatu VM dengan konfigurasi LVM. Asumsinya, disk sudah diextend dari sisi HVnya (PVE, ESXi, dll).\nPastikan penambahan space sudah terdeteksi dari VM melalui dmesg dan Anda akan mendapati informasi seperti ini:\n[262733.527587] sd 0:0:2:0: [abc] 4096-byte physical blocks [262733.528263] abc: detected capacity change from 214748364800 to 429496729600 Kalau ternyata belum terdeteksi, bisa dicoba untuk menjalankan perintah ini\necho 1 \u0026gt; /sys/class/block/\u0026lt;disk\u0026gt;/device/rescan Lalu coba cek kembali di dmesg. Kalau sudah muncul bisa langsung jalankan perintah berikut:\ngrowpart /dev/\u0026lt;disk\u0026gt; \u0026lt;no-partisi\u0026gt; # contoh `growpart /dev/sda 1` pvresize /dev/\u0026lt;partisi\u0026gt; # contoh `pvresize /dev/sda1` lvresize --extents +100%FREE --resizefs /dev/xxx/yyy # Value xxx yyy merujuk pada logical volume path Khusus untuk growpart jika tidak tersedia pada sistem Anda, maka bisa Anda gunakan parted\nparted /dev/\u0026lt;disk\u0026gt; (parted) resizepart \u0026lt;no-partisi\u0026gt; 100% (parted) quit Selesai. Semoga bermanfaat, insyaAllah\n","permalink":"https://blog.annahri.com/posts/jurnal-cara-extend-vm-disk-lvm/","summary":"Saya akan menjelaskan cara mudah untuk resize disk suatu VM dengan konfigurasi LVM. Asumsinya, disk sudah diextend dari sisi HVnya (PVE, ESXi, dll).\nPastikan penambahan space sudah terdeteksi dari VM melalui dmesg dan Anda akan mendapati informasi seperti ini:\n[262733.527587] sd 0:0:2:0: [abc] 4096-byte physical blocks [262733.528263] abc: detected capacity change from 214748364800 to 429496729600 Kalau ternyata belum terdeteksi, bisa dicoba untuk menjalankan perintah ini\necho 1 \u0026gt; /sys/class/block/\u0026lt;disk\u0026gt;/device/rescan Lalu coba cek kembali di dmesg.","title":"Jurnal: Cara Extend VM Disk untuk LVM"},{"content":" LEMP stack adalah software stack yang terdiri dari (L)inux, (E)gin-x alias Nginx, (M)ysql atau Mariadb, dan (P)HP.\nDi sini, saya akan menjelaskan bagaimana cara instalasi LEMP stack pada Ubuntu 20.04. Untuk OS berbasis RPM menyusul.\nKonfigurasi Awal Pastikan repositori Anda sudah pada kondisi terbaru dan package pada sistem anda terupgrade.\n$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Jika menggunakan firewall, pastikan port 80 (HTTP) dan 443 (HTTPS) terbuka. Kalau anda menggunakan ufw maka perintahnya adalah:\n$ sudo ufw allow proto tcp from any to any port 80,443 Gunakan perintah dibawah ini kalau Anda menggunakan iptables:\n$ sudo iptables -A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT # agar rule diatas menjadi \u0026#39;permanen\u0026#39; $ iptables-save | sudo tee /etc/iptables/rules.v4 Instalasi Stack Selanjutnya instal nginx, mariadb, dan php-fpm :\n$ sudo apt install -y \\ nginx \\ mariadb-server mariadb-common \\ php7.4-fpm php7.4 php7.4-common php7.4-mysql Pastikan semua service berjalan dengan baik :\n$ sudo systemctl status nginx $ sudo systemctl status mariadb $ sudo systemctl status php7.4-fpm Jika belum berjalan, maka jalankan service-service tersebut dengan perintah:\n$ sudo systemctl enable nginx --now $ sudo systemctl enable mariadb --now $ sudo systemctl enable php7.4-fpm --now Kemudian cek juga apakah port 80 sudah listen atau belum.\n$ sudo ss -tulpn | grep \u0026#39;:80\u0026#39; Untuk port 443 masih belum. Karena setelah instalasi baru, secara asal port 80 yang listen.\nTes Web Server Untuk itu, silahkan coba buka browser menggunakan alamat IP server. Atau juga bisa menggunakan domain. Jika memang sudah diatur A recordnya.\nAtau, pengecekan bisa dilakukan dengan menggunakan curl :\n$ curl localhost \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome to nginx!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;For online documentation and support please refer to \u0026lt;a href=\u0026#34;http://nginx.org/\u0026#34;\u0026gt;nginx.org\u0026lt;/a\u0026gt;.\u0026lt;br/\u0026gt; Commercial support is available at \u0026lt;a href=\u0026#34;http://nginx.com/\u0026#34;\u0026gt;nginx.com\u0026lt;/a\u0026gt;.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Thank you for using nginx.\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Tes Halaman PHP Buat file php dengan isi berikut, simpan di /var/www/html/phpinfo.php:\n\u0026lt;?php phpinfo(); ?\u0026gt; Kemudian pada browser / curl, silahkan coba akses http://IP SERVER/phpinfo.php:\n$ curl localhost/phpinfo.php \u0026lt;?php phpinfo(); ?\u0026gt; Kok tidak berhasil? Ya, karena nginx belum diatur untuk memproses halaman php.\nEdit file /etc/nginx/sites-available/default.conf kemudian cari baris berikut, dan hilangkan pagar-pagar didepannya (alias uncomment) :\nlocation ~ \\.php$ { include snippets/fastcgi-php.conf; # # With php-fpm (or other unix sockets): fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; } Sederhananya, blok diatas menginstrusikan nginx untuk memproses seluruh file yang berakhiran .php kepada php-fpm. Bisa melalui socket unix (unix:/path/to/socket.sock) atau socket tcp (IP:port).\nSetelah itu, reload konfigurasi nginx sudo nginx -s reload dan tes kembali menggunakan curl atau browser.\n$ curl localhost/phpinfo.php Jika menghasilkan halaman info php, maka konfigurasi sudah benar.\nKonfigurasi dan Tes Konektivitas Database Biasakan untuk selalu menjalankan mysql_secure_installation setiap kali menginstall mariadb-server atau mysql-server. Karena sesuai dengan namanya, perintah tersebut memastikan instalasi mysql itu aman alias secure.\n$ sudo mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we\u0026#39;ll need the current password for the root user. If you\u0026#39;ve just installed MariaDB, and you haven\u0026#39;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] Y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y Y ... Success! Normally, root should only be allowed to connect from \u0026#39;localhost\u0026#39;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] Y ... Success! By default, MariaDB comes with a database named \u0026#39;test\u0026#39; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y ... Success! Cleaning up... All done! If you\u0026#39;ve completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! Jawab setiap promptnya dengan Y.\nKemudian kita buat satu database percobaan dan satu database user.\n$ sudo mysql CREATE DATABASE tesdb; CREATE USER dbuser@localhost IDENTIFIED BY \u0026#39;password\u0026#39;; GRANT ALL PRIVILEGES ON tesdb.* TO dbuser@localhost; FLUSH PRIVILEGES; Buat satu file untuk uji coba konek php ke database. Simpan di /var/www/html/tesdb.php\n\u0026lt;?php $con = mysqli_connect(\u0026#34;localhost\u0026#34;,\u0026#34;dbuser\u0026#34;,\u0026#34;password\u0026#34;,\u0026#34;tesdb\u0026#34;); if (mysqli_connect_errno()) { echo \u0026#34;Failed to connect to MySQL: \u0026#34; . mysqli_connect_error(); exit(); } else { echo \u0026#34;Koneksi Database Berhasil.\u0026#34;; } ?\u0026gt; Tes kembali menggunakan browser atau curl, buka http://IP SERVER/testdb.php\n$ curl localhost/testdb.php Koneksi Database Berhasil. Selesai!\nKesimpulan Begitu mudahnya untuk melakukan instalasi LEMP stack pada Ubuntu 20.04. Cukup menginstal nginx + mysql/mariadb + php-fpm, dan sedikit konfigurasi pada nginx.\nTentunya akan memerlukan konfigurasi lebih lanjut jika hendak menginstal webapp semacam wordpress, dan semisalnya.\nSemoga bermanfaat, insyaAllah.\n","permalink":"https://blog.annahri.com/posts/lemp-stack-ubuntu20-04-focal/","summary":"LEMP stack adalah software stack yang terdiri dari (L)inux, (E)gin-x alias Nginx, (M)ysql atau Mariadb, dan (P)HP.\nDi sini, saya akan menjelaskan bagaimana cara instalasi LEMP stack pada Ubuntu 20.04. Untuk OS berbasis RPM menyusul.\nKonfigurasi Awal Pastikan repositori Anda sudah pada kondisi terbaru dan package pada sistem anda terupgrade.\n$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Jika menggunakan firewall, pastikan port 80 (HTTP) dan 443 (HTTPS) terbuka.","title":"Instalasi LEMP Stack (Linux, Nginx, MariaDB, PHP) pada Ubuntu 20.04"}]