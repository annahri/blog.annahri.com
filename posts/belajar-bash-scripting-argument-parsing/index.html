<!doctype html><html lang=id dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Belajar Bash Scripting: Argument Parsing | Linux & Cloud | blog.annahri.com</title>
<meta name=keywords content="bash,scripting"><meta name=description content="

Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.
Ini akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:
./script.sh -u username -h host 
# or
./script.sh --username user --host hostname
Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya."><meta name=author content="Muhammad Ahfas An Nahri"><link rel=canonical href=https://blog.annahri.com/posts/belajar-bash-scripting-argument-parsing/><link crossorigin=anonymous href=/assets/css/stylesheet.4d148c9804ddecb2970ce60ae056824dd84fa3dc796e721e5a82d7353d5b2ff8.css integrity="sha256-TRSMmATd7LKXDOYK4FaCTdhPo9x5bnIeWoLXNT1bL/g=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.annahri.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.annahri.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.annahri.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.annahri.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.annahri.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=id href=https://blog.annahri.com/posts/belajar-bash-scripting-argument-parsing/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://blog.annahri.com/css/custom_papermod.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CY69EEKCTJ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CY69EEKCTJ")}</script><meta property="og:title" content="Belajar Bash Scripting: Argument Parsing"><meta property="og:description" content="

Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.
Ini akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:
./script.sh -u username -h host 
# or
./script.sh --username user --host hostname
Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.annahri.com/posts/belajar-bash-scripting-argument-parsing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-24T14:39:03+07:00"><meta property="article:modified_time" content="2022-08-24T14:39:03+07:00"><meta property="og:site_name" content="Linux & Cloud | blog.annahri.com"><meta name=twitter:card content="summary"><meta name=twitter:title content="Belajar Bash Scripting: Argument Parsing"><meta name=twitter:description content="

Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.
Ini akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:
./script.sh -u username -h host 
# or
./script.sh --username user --host hostname
Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.annahri.com/posts/"},{"@type":"ListItem","position":2,"name":"Belajar Bash Scripting: Argument Parsing","item":"https://blog.annahri.com/posts/belajar-bash-scripting-argument-parsing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Belajar Bash Scripting: Argument Parsing","name":"Belajar Bash Scripting: Argument Parsing","description":" Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.\nIni akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:\n./script.sh -u username -h host # or ./script.sh --username user --host hostname Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya.\n","keywords":["bash","scripting"],"articleBody":" Pada artikel kali ini, saya akan membahas mengenai Argument Parsing. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (positional argument), atau sesuai ketentuan yang ditentukan nantinya.\nIni akan sangat bermanfaat jika Anda hendak membuat CLI tool dari bash script. Misalnya membuat tool seperti berikut:\n./script.sh -u username -h host # or ./script.sh --username user --host hostname Telah dibahas pada artikel yang telah lalu (Belajar Bash Scripting: Arguments) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel $1, $2 dan seterusnya.\nPositional Argument Yang dimaksud dengan positional argument, secara umum adalah argumen yang ditentukan dari urutannya ($1 .. $n), dan secara khusus, yaitu argumen yang sudah ditetapkan tujuannya sesuai dengan urutan penyebutannya. Misalnya pada tool rsync:\nrsync sourcefiles user@remote:/destination/ Bisa didapati bahwa argumen pertama merupakan spesifikasi untuk file sumber yang hendak ditransfer kemudian argumen terakhir adalah tujuannya, entah di lokal atau remote.\nSehingga, argumen pertama akan selalu menjadi sumber file dan argumen kedua akan selalu menjadi tujuannya. Jikalau dibalik, tidak bisa, destinasi tujuan didefinisikan pada argumen pertama dan seterusnya.\nAtau pada utilitas mv atau cp, yang ketentuannya adalah jika diberikan 2 nama file, maka yang pertama menjadi sumber file dan yang kedua menjadi tujuan file (hasil salinan, atau hasil pindahan). Namun, jika diberikan lebih dari 2 file, maka argumen paling akhir akan menjadi tujuannya.\ncp file1 file2 file3 target/ mv fileA fileB fileXYZ target/ Maka sudah menjadi ketentuan, bahwa file/folder yang disebutkan paling akhir, maka file/folder tersebut akan menjadi targetnya.\nInilah yang dimaksud dengan positional argument.\nOptional Argument Optional argument adalah argument yang tidak wajib untuk diberikan. Boleh diberikan dan boleh juga tidak. Ini berfungsi untuk mengubah sifat suatu tool berdasarkan flag/option yang diberikan. Misalkan pada rysnc:\nrsync --dry-run --delete sourcefiles user@remote:/destination/ Lho, katanya argumen pertama itu untuk spesifikasi file/folder sumber dan argumen kedua untuk tujuannya? Bukankah pada contoh ini, argumen pertama ($1) adalah --dry-run? kemudian argumen kedua adalah --delete? dan yang ketiga dan keempat baru sumber dan tujuan?\nJawabannya, benar. Jika diruntut, memang terbaca seperti itu ($1 = '--dry-run' dan seterusnya). Ini karena argument parsing. Tiap argumen yang diberikan akan diproses satu-persatu menyesuaikan dengan pola argumen yang diberikan.\nTool rsync tersebut, diprogram sedemikian rupa sehingga ketika didapati ada argument yang berawalan -- atau - maka akan dianggap sebagai optional parameter, dan akan diproses berdasarkan string setelahnya. Misalnya pada contoh diatas, --dry-run maka rysnc akan berjalan pada mode dry run alias percobaan.\nArgument Parsing Argument parsing sebenarnya bisa dilakukan dengan built-in tool getopts. Namun, pada artikel ini saya hanya akan membahas argument parsing menggunakan while dan for loop yang dikombinasikan dengan kondisional case.\nContoh skenarionya adalah seperti ini:\n./script.sh -a -b opt1 --xyz opt2 pos1 pos2 Maka akan didapatkan variabel $@ yang isinya:\n-a -b opt1 --xyz opt2 pos1 pos2 dan $# yang bernilai 7.\nüí° Variabel $# bernilai sejumlah dengan seluruh argumen yang diberikan.\nDengan demikian maka bisa diproses masing-masing argumennya dengan loop berikut:\n#!/usr/bin/env bash while [[ $# -ne 0 ]]; do case \"$1\" in -a) option_a=\"set\" shift ;; -b) option_b=\"$2\" shift 2 ;; --xyz) option_xyz=\"$2\" shift 2 ;; *) positional_arg+=( \"$1\" ) shift ;; esac done printf '%s: %s\\n' option_a \"$option_a\" option_b \"$option_b\" option_xyz \"$option_xyz\" echo \"Positional args: ${positional_arg[*]}\" Penjelasan Bagian while [[ $# -ne 0 ]]; do akan melakukan loop selama $# tidak bernilai nol, alias selama masih ada argumen yang bisa diproses, pemrosesan akan terus berlanjut.\nKemudian case \"$1\" in akan mengecek argumen pertama dan akan mecocokkannya dengan case-case yang didefinisikan setelahnya. Kenapa hanya argumen pertama saja? Akan datang penjelasannya nanti.\nCase-case yang dimaksud adalah seperti pada contoh, adalah -a, -b, --xyz dan *. Mari dibahas satu-persatu:\n-a) option_a=\"set\" shift ;; Nah, ketika $1 bernilai -a, maka kita akan definisikan variabel option_a dengan nilai set. Kemudian ada sintaks shift, yang berfungsi untuk menggser positional parameter yang diberikan. Maksudnya bagaimana?\nSeperti yang sudah diketahui sebelumnya, bahwa pada contoh command sebelumnya, argumen-argumen yang diberikan adalah sebagai berikut:\n-a -b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 $5 $6 $7 # $# = 7 Jika command shift dipanggil, maka penyematan argumen akan menjadi seperti ini:\n-a -b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 $5 $6 # $# = 6 Kemudian, jika shift dipanggil dan diberikan nilai padanya, maka pergeseran argumen akan dilakukan sebanyak nilai yang diberikan. Misalnya shift 2:\n-a -b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 # $# = 4 Karena positional argument-nya bergeser, maka jumlahnya ($#) juga berubah pula, sebagaimana pada contoh diatas.\nKembali ke pembahasan sebelumnya, karena kondisi $1 saat ini bernilai -a maka kita isikan variabel option_a dengan nilai set dan kita geser positional argumen selanjutnya menggunakan perintah shift. Sehingga kondisi $1 saat ini menjadi argumen setelahnya, tidak lagi -a.\nSetelah shift diberlakukan, maka pengkondisian case selesai dan kembali kepada loop untuk melakukan iterasi berikutnya karena $# masih belum bernilai 0. Selanjutnya:\n-b) option_b=\"$2\" shift 2 ;; dengan kondisi $@ yang saat ini adalah seperti berikut ini:\n-b opt1 --xyz opt2 pos1 pos2 $1 $2 $3 $4 $5 $6 maka, karena $1 saat ini bernilai -b maka kita deklarasikan variabel option_b dengan memberikannya nilai sesuai dengan nilai variabel $2 yaitu opt1. Setelah itu kita geser kembali argumennya 2 kali. Sehingga, kondisi $@ saat ini menjadi:\n--xyz opt2 pos1 pos2 $1 $2 $3 $4 Untuk bagian dibawah ini, pembahasannya sama dengan -b:\n--xyz) option_xyz=\"$2\" shift 2 ;; Kemudian yang terkahir adalah:\n*) positional_arg+=( \"$1\" ) shift ;; Ini berarti, semua argumen yang bukan berupa option (diawali dengan -), maka akan teranggap sebagai positional argument dan akan dimasukkan ke array positional_arg yang akan diproses tersendiri nantinya.\nDengan demikian, output dari command berikut ini:\n./script.sh -a -b opt1 --xyz opt2 pos1 pos2 adalah\noption_a: set option_b: opt1 option_xyz: opt2 Positional args: pos1 pos2 Parsing bentuk ‚Äìopt=value dan -oValue Setelah dijelaskan konsep dasar pemanfaatan WHILE loop dan CASE statement untuk argument parsing seperti pada contoh sebelumnya, saya akan jelaskan pula bagaimana cara untuk membuat parsing dengan model seperti ini:\n./script.sh --opt1=value1 --flag1=value2 ... Susunan WHILE loop sama seperti dengan contoh sebelumnya, namun bisa diperingkas seperti berikut agar mengurangi kedalaman indentasi:\n#!/usr/bin/env bash while [[ $# -ne 0 ]]; do case \"$1\" in --flag1=*) var_flag1=\"${1#*=}\";; --opt1=*) var_opt1=\"${1#*=}\" ;; *) echo \"Opsi tidak dikenali.\"; exit 1;; esac; shift; done printf '%s: %s\\n' \\ 'Flag1' \"$var_flag1\" \\ 'Opt1' \"$var_opt1\" üí° Sintaks shift pada contoh ini tidak lagi diletakkan pada tiap-tiap case yang diberikan karena itu redundan. Sehingga cukup diletakkan sekali saja setelah block case diakhir tiap loop.\nNah, pada contoh diatas, saya memanfaatkan suatu fitur dari Bash yaitu parameter expansion yang akan dibahas lebih detail pada artikel lain nantinya.\nParameter expansion yang dimanfaatkan adalah ${variabel#*PATTERN} yang fungsinya adalah menghapus seluruh karakter dari awal hingga bertemu PATTERN. Pada contoh diatas adalah ${1#*=}.\nAnggap saja nilai $1 saat ini adalah --flag1=hehe, fokus pada parameter #*=, maka bisa diartikan dengan ‚Äúmenghapus seluruh karakter dari awal hingga bertemu dengan karakter = (inklusif)‚Äù. Sehingga hasilnya adalah hehe.\nKemudian, contoh selanjutnya adalah argument parsing semisal pada command mysql:\nmysql -uroot -hhostname -p Hampir sama dengan contoh sebelumnya, hanya berbeda pada sintaks parameter expansion saja dan pada klausa CASEnya:\n#!/usr/bin/env bash while [[ $# -ne 0 ]]; do case \"$1\" in -u*) username=\"${1#*-u}\";; -h*) password=\"${1#*-h}\";; -p) prompt_password=1 ;; *) echo \"Opsi tidak dikenali.\"; exit 1;; esac; shift; done printf '%s: %s\\n' \\ 'Username' \"$username\" \\ 'Hostname' \"$hostname\" if [[ -n \"$prompt_password\" ]]; then read -r -s -p \"Kata sandi: \" password fi Argument parsing dengan FOR loop FOR loop juga bisa digunakan untuk melakukan argument parsing. Namun dengan batasan, bahwa argument parsing yang dilakukan tidak bisa berupa opsi/flag yang meminta value. Hanya bisa berupa opsi/flag yang bersifat toggle (alias, on/off) dan juga positional argument saja. Misal:\n./script.sh --force --delete #!/usr/bin/env bash for arg in \"$@\"; do case \"$arg\" in --force) force_enable=true ;; --delete) delete_enable=true ;; *) echo \"Opsi tidak dikenali.\"; exit 1 ;; esac; done ... Pada model ini, kita memanfaatkan variabel $@ dan tidak perlu memanggil shift karena tiap iterasinya, FOR loop akan mengkonsumsi semua ekspansi $@ satu persatu. Bentuknya menjadi lebih ringkas namun kurang fleksibel.\nValidasi Tentunya, setiap pemberian opsi dan/atau positional argument perlu diberlakukan validasi terlebih dahulu. Misalnya script tidak memperbolehkan penggunaan flag/opsi yang sama lebih dari satu, atau jika opsi yang satu sudah diberikan maka opsi yang lain tidak boleh diberikan pula.\nStrategi untuk mengatasi kondisi semacam itu beragam. Diantaranya bisa dengan misalnya opsi yang terakhir diberikan maka itu yang akan dipertimbangkan. Atau pemberian prioritas, atau bahkan script akan error jika bertemu kondisi-kondisi tersebut.\nHal ini bisa dilakukan langsung pada bagian kondisional CASE atau setelah argument parsing selesai.\nContohnya pada utilitas mv atau rm pada opsi -i dan -f-nya:\nrm -i -f file2 Opsi -i berfungsi agar perintah rm memberikan prompt sebelum penghapusan file dilakukan. Sedangkan -f adalah opsi yang digunakan agar rm menghapus ‚Äúpaksa‚Äù suatu file tanpa menanyakan/memberitahukan terkait ada/tidaknya file yang dimaksud. Tentu keduanya bertentangan satu sama lain. Bagaimana rm menangani kondisi ini? Yaitu dengan memprioritaskan opsi yang paling akhir.\nSehingga bisa saja suatu script disusun seperti ini untuk meniru gaya argument parsing pada cp:\n... while [[ $# -ne 0 ]]; do case \"$1\" in ... -i) option=\"interactive\"; shift ;; -f) option=\"force\"; shift ;; ... esac done ... dengan demikian, variabel option akan memiliki nilai sesuai dengan opsi yang ditentukan paling akhir.\nKemudian, suatu script dimana script tersebut memerlukan variabel tertentu agar diset oleh user, namun jika tidak diberikan, variabel tersebut akan terisi dengan nilai default. Misalnya pada tool iptables. Tool tersebut memerlukan ditentukannya nama tabel agar bisa menampilkan semua rules-nya dengan flag -L.\niptables -t nat -L Jika, opsti -t nat tidak diberikan, maka secara asal, iptables akan menampilkan rules pada tabel filter. Contoh pada script:\n... while [[ $# -ne 0 ]]; do case \"$1\" in ... -t) table=\"$2\"; shift 2 ;; ... esac done ... if [[ -z \"$table\" ]]; then table=filter fi atau lebih sederhana, menggunakan parameter expansion:\n... case \"$1\" in ... -t) table=\"${2:-filter}\"; shift 2 ;; ... esac ... ‚òùÔ∏è Yang maknanya, jika variabel $2 itu UNSET atau bernilai kosong (empty string), maka isi variabel table dengan string filter.\nBagaimana dengan bentuk option/flag seperti contoh dibawah ini?\ntar xvzf archive.tar.gz # atau rsync rsync -avznP source/ user@host:/dest/ # atau ps ps aux # atau ss/netstat ss -ant netstat -patlun Saya serahkan pada pembaca untuk mencari tahu.\nSemoga bermanfaat, barakallahufiikum.\n","wordCount":"1710","inLanguage":"id","datePublished":"2022-08-24T14:39:03+07:00","dateModified":"2022-08-24T14:39:03+07:00","author":[{"@type":"Person","name":"Muhammad Ahfas An Nahri"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.annahri.com/posts/belajar-bash-scripting-argument-parsing/"},"publisher":{"@type":"Organization","name":"Linux \u0026 Cloud | blog.annahri.com","logo":{"@type":"ImageObject","url":"https://blog.annahri.com/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://blog.annahri.com/ accesskey=h title="Linux & Cloud | blog.annahri.com (Alt + H)">Linux & Cloud | blog.annahri.com</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.annahri.com/arsip/ title=Arsip><span>Arsip</span></a></li><li><a href=https://blog.annahri.com/categories/ title=Kategori><span>Kategori</span></a></li><li><a href=https://blog.annahri.com/tags/ title=Tagar><span>Tagar</span></a></li><li><a href=https://blog.annahri.com/cari/ title=Pencarian><span>Pencarian</span></a></li><li><a href=https://blog.annahri.com/tentang/ title=Tentang><span>Tentang</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.annahri.com/>Beranda</a>&nbsp;¬ª&nbsp;<a href=https://blog.annahri.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Belajar Bash Scripting: Argument Parsing</h1><div class=post-meta><span class=post-date date-time='2022-08-24 14:39:03 +0700 +0700'>24 Agustus 2022</span>&nbsp;¬∑&nbsp;9 menit&nbsp;¬∑&nbsp;Muhammad Ahfas An Nahri&nbsp;|&nbsp;<a href=https://github.com/annahri/blog.annahri.com/tree/main/content/posts/belajar-bash-scripting-argument-parsing.md rel="noopener noreferrer" target=_blank>Sarankan Pengubahan</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Daftar isi</span></summary><div class=inner><ul><li><a href=#positional-argument aria-label="Positional Argument">Positional Argument</a></li><li><a href=#optional-argument aria-label="Optional Argument">Optional Argument</a></li><li><a href=#argument-parsing aria-label="Argument Parsing">Argument Parsing</a><ul><li><a href=#penjelasan aria-label=Penjelasan>Penjelasan</a></li><li><a href=#parsing-bentuk---optvalue-dan--ovalue aria-label="Parsing bentuk &ndash;opt=value dan -oValue">Parsing bentuk &ndash;opt=value dan -oValue</a></li><li><a href=#argument-parsing-dengan-for-loop aria-label="Argument parsing dengan FOR loop">Argument parsing dengan FOR loop</a></li></ul></li><li><a href=#validasi aria-label=Validasi>Validasi</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=/images/bismillah-2.png#center alt=Bismillah></p><p>Pada artikel kali ini, saya akan membahas mengenai <em>Argument Parsing</em>. Yakni adalah bagaimana cara agar setiap argumen yang diberikan pada suatu fungsi/script, bisa diinterpretasi sesuai posisinya (<em>positional argument</em>), atau sesuai ketentuan yang ditentukan nantinya.</p><p>Ini akan sangat bermanfaat jika Anda hendak membuat CLI <em>tool</em> dari bash script. Misalnya membuat tool seperti berikut:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./script.sh -u username -h host 
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># or</span>
</span></span><span style=display:flex><span>./script.sh --username user --host hostname
</span></span></code></pre></div><p>Telah dibahas pada artikel yang telah lalu (<a href=/posts/belajar-bash-scripting-arguments/>Belajar Bash Scripting: Arguments</a>) bahwa bash akan menginterpretasi setiap argumen yang diberikan dengan variabel <code>$1</code>, <code>$2</code> dan seterusnya.</p><h2 id=positional-argument>Positional Argument<a hidden class=anchor aria-hidden=true href=#positional-argument>#</a></h2><p>Yang dimaksud dengan <em>positional argument</em>, secara umum adalah argumen yang ditentukan dari urutannya (<code>$1 .. $n</code>), dan secara khusus, yaitu argumen yang sudah ditetapkan tujuannya sesuai dengan urutan penyebutannya. Misalnya pada tool <code>rsync</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rsync sourcefiles user@remote:/destination/
</span></span></code></pre></div><p>Bisa didapati bahwa argumen pertama merupakan spesifikasi untuk file sumber yang hendak ditransfer kemudian argumen terakhir adalah tujuannya, entah di lokal atau <em>remote</em>.</p><p>Sehingga, argumen pertama akan selalu menjadi sumber file dan argumen kedua akan selalu menjadi tujuannya. Jikalau dibalik, tidak bisa, destinasi tujuan didefinisikan pada argumen pertama dan seterusnya.</p><p>Atau pada utilitas <code>mv</code> atau <code>cp</code>, yang ketentuannya adalah jika diberikan 2 nama file, maka yang pertama menjadi sumber file dan yang kedua menjadi tujuan file (hasil salinan, atau hasil pindahan). Namun, jika diberikan lebih dari 2 file, maka argumen paling akhir akan menjadi tujuannya.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cp file1 file2 file3 target/
</span></span><span style=display:flex><span>mv fileA fileB fileXYZ target/
</span></span></code></pre></div><p>Maka sudah menjadi ketentuan, bahwa file/folder yang disebutkan paling akhir, maka file/folder tersebut akan menjadi targetnya.</p><p>Inilah yang dimaksud dengan <em>positional argument</em>.</p><h2 id=optional-argument>Optional Argument<a hidden class=anchor aria-hidden=true href=#optional-argument>#</a></h2><p><em>Optional argument</em> adalah argument yang tidak wajib untuk diberikan. Boleh diberikan dan boleh juga tidak. Ini berfungsi untuk mengubah sifat suatu tool berdasarkan <em>flag/option</em> yang diberikan. Misalkan pada <code>rysnc</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rsync --dry-run --delete sourcefiles user@remote:/destination/
</span></span></code></pre></div><p>Lho, katanya argumen pertama itu untuk spesifikasi file/folder sumber dan argumen kedua untuk tujuannya? Bukankah pada contoh ini, argumen pertama (<code>$1</code>) adalah <code>--dry-run</code>? kemudian argumen kedua adalah <code>--delete</code>? dan yang ketiga dan keempat baru sumber dan tujuan?</p><p>Jawabannya, benar. Jika diruntut, memang terbaca seperti itu (<code>$1 = '--dry-run'</code> dan seterusnya). Ini karena <em>argument parsing</em>. Tiap argumen yang diberikan akan diproses satu-persatu menyesuaikan dengan pola argumen yang diberikan.</p><p>Tool <code>rsync</code> tersebut, diprogram sedemikian rupa sehingga ketika didapati ada argument yang berawalan <code>--</code> atau <code>-</code> maka akan dianggap sebagai <em>optional parameter</em>, dan akan diproses berdasarkan string setelahnya. Misalnya pada contoh diatas, <code>--dry-run</code> maka <code>rysnc</code> akan berjalan pada mode <em>dry run</em> alias percobaan.</p><h2 id=argument-parsing>Argument Parsing<a hidden class=anchor aria-hidden=true href=#argument-parsing>#</a></h2><p><em>Argument parsing</em> sebenarnya bisa dilakukan dengan <em>built-in tool</em> <code>getopts</code>. Namun, pada artikel ini saya hanya akan membahas <em>argument parsing</em> menggunakan <code>while</code> dan <code>for</code> loop yang dikombinasikan dengan kondisional <code>case</code>.</p><p>Contoh skenarionya adalah seperti ini:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./script.sh -a -b opt1 --xyz opt2 pos1 pos2
</span></span></code></pre></div><p>Maka akan didapatkan variabel <code>$@</code> yang isinya:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-a -b opt1 --xyz opt2 pos1 pos2
</span></span></code></pre></div><p>dan <code>$#</code> yang bernilai 7.</p><style>.callout{color:#f7f4ef;background:#3e3e4f;padding:1em 1.25em;border-radius:3px;display:flex;flex-direction:row;margin:20px auto}.callout code{background-color:transparent}.callout-inner{margin-left:1em}r .callout div p{margin:0}@media(max-width:767px){.callout{padding:1.5em .75em 1.5em .6em}.callout-inner{margin-left:.5em}}</style><div class=callout><div>üí°</div><div class=callout-inner><p>Variabel <code>$#</code> bernilai sejumlah dengan seluruh argumen yang diberikan.</p></div></div><p>Dengan demikian maka bisa diproses masing-masing argumennya dengan loop berikut:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8ec07c>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>[[</span> $# -ne <span style=color:#d3869b>0</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>do</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>        -a<span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>            option_a<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;set&#34;</span>            
</span></span><span style=display:flex><span>            <span style=color:#fabd2f>shift</span>
</span></span><span style=display:flex><span>            ;;
</span></span><span style=display:flex><span>        -b<span style=color:#fe8019>)</span> 
</span></span><span style=display:flex><span>            option_b<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span>$2<span style=color:#b8bb26>&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#fabd2f>shift</span> <span style=color:#d3869b>2</span>
</span></span><span style=display:flex><span>            ;;
</span></span><span style=display:flex><span>        --xyz<span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>            option_xyz<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span>$2<span style=color:#b8bb26>&#34;</span> 
</span></span><span style=display:flex><span>            <span style=color:#fabd2f>shift</span> <span style=color:#d3869b>2</span>
</span></span><span style=display:flex><span>            ;;
</span></span><span style=display:flex><span>        *<span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>            positional_arg<span style=color:#fe8019>+=(</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> <span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>            <span style=color:#fabd2f>shift</span>
</span></span><span style=display:flex><span>            ;;
</span></span><span style=display:flex><span>    <span style=color:#fe8019>esac</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#39;%s: %s\n&#39;</span> option_a <span style=color:#b8bb26>&#34;</span>$option_a<span style=color:#b8bb26>&#34;</span> option_b <span style=color:#b8bb26>&#34;</span>$option_b<span style=color:#b8bb26>&#34;</span> option_xyz <span style=color:#b8bb26>&#34;</span>$option_xyz<span style=color:#b8bb26>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Positional args: </span><span style=color:#b8bb26>${</span>positional_arg[*]<span style=color:#b8bb26>}</span><span style=color:#b8bb26>&#34;</span>
</span></span></code></pre></div><h3 id=penjelasan>Penjelasan<a hidden class=anchor aria-hidden=true href=#penjelasan>#</a></h3><p>Bagian <code>while [[ $# -ne 0 ]]; do</code> akan melakukan loop selama <code>$#</code> tidak bernilai nol, alias selama masih ada argumen yang bisa diproses, pemrosesan akan terus berlanjut.</p><p>Kemudian <code>case "$1" in</code> akan mengecek argumen pertama dan akan mecocokkannya dengan <em>case-case</em> yang didefinisikan setelahnya. Kenapa hanya argumen pertama saja? Akan datang penjelasannya nanti.</p><p><em>Case-case</em> yang dimaksud adalah seperti pada contoh, adalah <code>-a</code>, <code>-b</code>, <code>--xyz</code> dan <code>*</code>. Mari dibahas satu-persatu:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-a<span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>    option_a<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;set&#34;</span>            
</span></span><span style=display:flex><span>    <span style=color:#fabd2f>shift</span>
</span></span><span style=display:flex><span>    ;;
</span></span></code></pre></div><p>Nah, ketika <code>$1</code> bernilai <code>-a</code>, maka kita akan definisikan variabel <code>option_a</code> dengan nilai <code>set</code>. Kemudian ada sintaks <code>shift</code>, yang berfungsi untuk menggser <em>positional parameter</em> yang diberikan. Maksudnya bagaimana?</p><p>Seperti yang sudah diketahui sebelumnya, bahwa pada contoh command sebelumnya, argumen-argumen yang diberikan adalah sebagai berikut:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-a -b opt1 --xyz opt2 pos1 pos2
</span></span><span style=display:flex><span>$1 $2  $3    $4   $5   $6   $7
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># $# = 7</span>
</span></span></code></pre></div><p>Jika <em>command</em> <code>shift</code> dipanggil, maka penyematan argumen akan menjadi seperti ini:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-a -b opt1 --xyz opt2 pos1 pos2
</span></span><span style=display:flex><span>   $1  $2    $3   $4   $5   $6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># $# = 6</span>
</span></span></code></pre></div><p>Kemudian, jika <code>shift</code> dipanggil dan diberikan nilai padanya, maka pergeseran argumen akan dilakukan sebanyak nilai yang diberikan. Misalnya <code>shift 2</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-a -b opt1 --xyz opt2 pos1 pos2
</span></span><span style=display:flex><span>             $1   $2   $3   $4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># $# = 4</span>
</span></span></code></pre></div><p>Karena <em>positional argument</em>-nya bergeser, maka jumlahnya (<code>$#</code>) juga berubah pula, sebagaimana pada contoh diatas.</p><p>Kembali ke pembahasan sebelumnya, karena kondisi <code>$1</code> saat ini bernilai <code>-a</code> maka kita isikan variabel <code>option_a</code> dengan nilai <code>set</code> dan kita geser positional argumen selanjutnya menggunakan perintah <code>shift</code>. Sehingga kondisi <code>$1</code> saat ini menjadi argumen setelahnya, tidak lagi <code>-a</code>.</p><p>Setelah <code>shift</code> diberlakukan, maka pengkondisian <code>case</code> selesai dan kembali kepada loop untuk melakukan iterasi berikutnya karena <code>$#</code> masih belum bernilai 0. Selanjutnya:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-b<span style=color:#fe8019>)</span> 
</span></span><span style=display:flex><span>    option_b<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span>$2<span style=color:#b8bb26>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#fabd2f>shift</span> <span style=color:#d3869b>2</span>
</span></span><span style=display:flex><span>    ;;
</span></span></code></pre></div><p>dengan kondisi <code>$@</code> yang saat ini adalah seperti berikut ini:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>-b opt1 --xyz opt2 pos1 pos2
</span></span><span style=display:flex><span>$1  $2    $3   $4   $5   $6
</span></span></code></pre></div><p>maka, karena <code>$1</code> saat ini bernilai <code>-b</code> maka kita deklarasikan variabel <code>option_b</code> dengan memberikannya nilai sesuai dengan nilai variabel <code>$2</code> yaitu <code>opt1</code>. Setelah itu kita geser kembali argumennya 2 kali. Sehingga, kondisi <code>$@</code> saat ini menjadi:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>--xyz opt2 pos1 pos2
</span></span><span style=display:flex><span>  $1   $2   $3   $4
</span></span></code></pre></div><p>Untuk bagian dibawah ini, pembahasannya sama dengan <code>-b</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>--xyz<span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>    option_xyz<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span>$2<span style=color:#b8bb26>&#34;</span> 
</span></span><span style=display:flex><span>    <span style=color:#fabd2f>shift</span> <span style=color:#d3869b>2</span>
</span></span><span style=display:flex><span>    ;;
</span></span></code></pre></div><p>Kemudian yang terkahir adalah:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>*<span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>    positional_arg<span style=color:#fe8019>+=(</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> <span style=color:#fe8019>)</span>
</span></span><span style=display:flex><span>    <span style=color:#fabd2f>shift</span>
</span></span><span style=display:flex><span>    ;;
</span></span></code></pre></div><p>Ini berarti, semua argumen yang bukan berupa option (diawali dengan <code>-</code>), maka akan teranggap sebagai <em>positional argument</em> dan akan dimasukkan ke <em>array</em> <code>positional_arg</code> yang akan diproses tersendiri nantinya.</p><p>Dengan demikian, output dari command berikut ini:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./script.sh -a -b opt1 --xyz opt2 pos1 pos2
</span></span></code></pre></div><p>adalah</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>option_a: set
</span></span><span style=display:flex><span>option_b: opt1
</span></span><span style=display:flex><span>option_xyz: opt2
</span></span><span style=display:flex><span>Positional args: pos1 pos2
</span></span></code></pre></div><h3 id=parsing-bentuk---optvalue-dan--ovalue>Parsing bentuk &ndash;opt=value dan -oValue<a hidden class=anchor aria-hidden=true href=#parsing-bentuk---optvalue-dan--ovalue>#</a></h3><p>Setelah dijelaskan konsep dasar pemanfaatan WHILE loop dan CASE <em>statement</em> untuk <em>argument parsing</em> seperti pada contoh sebelumnya, saya akan jelaskan pula bagaimana cara untuk membuat <em>parsing</em> dengan model seperti ini:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./script.sh --opt1<span style=color:#fe8019>=</span>value1 --flag1<span style=color:#fe8019>=</span>value2 ...
</span></span></code></pre></div><p>Susunan WHILE <em>loop</em> sama seperti dengan contoh sebelumnya, namun bisa diperingkas seperti berikut agar mengurangi kedalaman indentasi:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8ec07c>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>[[</span> $# -ne <span style=color:#d3869b>0</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>do</span> <span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>    --flag1<span style=color:#fe8019>=</span>*<span style=color:#fe8019>)</span> var_flag1<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>${</span>1#*=<span style=color:#b8bb26>}</span><span style=color:#b8bb26>&#34;</span>;;
</span></span><span style=display:flex><span>    --opt1<span style=color:#fe8019>=</span>*<span style=color:#fe8019>)</span>  var_opt1<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>${</span>1#*=<span style=color:#b8bb26>}</span><span style=color:#b8bb26>&#34;</span> ;;
</span></span><span style=display:flex><span>    *<span style=color:#fe8019>)</span> <span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Opsi tidak dikenali.&#34;</span>; <span style=color:#fabd2f>exit</span> 1;;
</span></span><span style=display:flex><span><span style=color:#fe8019>esac</span>; shift; <span style=color:#fe8019>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#39;%s: %s\n&#39;</span> <span style=color:#b8bb26>\
</span></span></span><span style=display:flex><span><span style=color:#b8bb26></span>    <span style=color:#b8bb26>&#39;Flag1&#39;</span> <span style=color:#b8bb26>&#34;</span>$var_flag1<span style=color:#b8bb26>&#34;</span> <span style=color:#b8bb26>\
</span></span></span><span style=display:flex><span><span style=color:#b8bb26></span>    <span style=color:#b8bb26>&#39;Opt1&#39;</span> <span style=color:#b8bb26>&#34;</span>$var_opt1<span style=color:#b8bb26>&#34;</span>
</span></span></code></pre></div><style>.callout{color:#f7f4ef;background:#3e3e4f;padding:1em 1.25em;border-radius:3px;display:flex;flex-direction:row;margin:20px auto}.callout code{background-color:transparent}.callout-inner{margin-left:1em}r .callout div p{margin:0}@media(max-width:767px){.callout{padding:1.5em .75em 1.5em .6em}.callout-inner{margin-left:.5em}}</style><div class=callout><div>üí°</div><div class=callout-inner><p>Sintaks <code>shift</code> pada contoh ini tidak lagi diletakkan pada tiap-tiap <em>case</em> yang diberikan karena itu redundan. Sehingga cukup diletakkan sekali saja setelah <em>block case</em> diakhir tiap <em>loop</em>.</p></div></div><p>Nah, pada contoh diatas, saya memanfaatkan suatu fitur dari Bash yaitu <em>parameter expansion</em> yang akan dibahas lebih detail pada artikel lain nantinya.</p><p><em>Parameter expansion</em> yang dimanfaatkan adalah <code>${variabel#*PATTERN}</code> yang fungsinya adalah menghapus seluruh karakter dari awal hingga bertemu PATTERN. Pada contoh diatas adalah <code>${1#*=}</code>.</p><p>Anggap saja nilai <code>$1</code> saat ini adalah <code>--flag1=hehe</code>, fokus pada parameter <code>#*=</code>, maka bisa diartikan dengan &ldquo;menghapus seluruh karakter dari awal hingga bertemu dengan karakter <code>=</code> (inklusif)&rdquo;. Sehingga hasilnya adalah <code>hehe</code>.</p><p>Kemudian, contoh selanjutnya adalah argument parsing semisal pada <em>command</em> <code>mysql</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mysql -uroot -hhostname -p
</span></span></code></pre></div><p>Hampir sama dengan contoh sebelumnya, hanya berbeda pada sintaks <em>parameter expansion</em> saja dan pada klausa CASEnya:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8ec07c>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>[[</span> $# -ne <span style=color:#d3869b>0</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>do</span> <span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>    -u*<span style=color:#fe8019>)</span> username<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>${</span>1#*-u<span style=color:#b8bb26>}</span><span style=color:#b8bb26>&#34;</span>;;
</span></span><span style=display:flex><span>    -h*<span style=color:#fe8019>)</span> password<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>${</span>1#*-h<span style=color:#b8bb26>}</span><span style=color:#b8bb26>&#34;</span>;;
</span></span><span style=display:flex><span>    -p<span style=color:#fe8019>)</span>  prompt_password<span style=color:#fe8019>=</span><span style=color:#d3869b>1</span> ;;
</span></span><span style=display:flex><span>    *<span style=color:#fe8019>)</span> <span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Opsi tidak dikenali.&#34;</span>; <span style=color:#fabd2f>exit</span> 1;;
</span></span><span style=display:flex><span><span style=color:#fe8019>esac</span>; shift; <span style=color:#fe8019>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fabd2f>printf</span> <span style=color:#b8bb26>&#39;%s: %s\n&#39;</span> <span style=color:#b8bb26>\
</span></span></span><span style=display:flex><span><span style=color:#b8bb26></span>    <span style=color:#b8bb26>&#39;Username&#39;</span> <span style=color:#b8bb26>&#34;</span>$username<span style=color:#b8bb26>&#34;</span> <span style=color:#b8bb26>\
</span></span></span><span style=display:flex><span><span style=color:#b8bb26></span>    <span style=color:#b8bb26>&#39;Hostname&#39;</span> <span style=color:#b8bb26>&#34;</span>$hostname<span style=color:#b8bb26>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>if</span> <span style=color:#fe8019>[[</span> -n <span style=color:#b8bb26>&#34;</span>$prompt_password<span style=color:#b8bb26>&#34;</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>then</span>
</span></span><span style=display:flex><span>    <span style=color:#fabd2f>read</span> -r -s -p <span style=color:#b8bb26>&#34;Kata sandi: &#34;</span> password
</span></span><span style=display:flex><span><span style=color:#fe8019>fi</span>
</span></span></code></pre></div><h3 id=argument-parsing-dengan-for-loop>Argument parsing dengan FOR loop<a hidden class=anchor aria-hidden=true href=#argument-parsing-dengan-for-loop>#</a></h3><p>FOR <em>loop</em> juga bisa digunakan untuk melakukan <em>argument parsing</em>. Namun dengan batasan, bahwa <em>argument parsing</em> yang dilakukan tidak bisa berupa opsi/flag yang meminta value. Hanya bisa berupa opsi/flag yang bersifat <em>toggle</em> (alias, on/off) dan juga <em>positional argument</em> saja. Misal:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./script.sh --force --delete
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8ec07c>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#8ec07c></span>
</span></span><span style=display:flex><span><span style=color:#fe8019>for</span> arg in <span style=color:#b8bb26>&#34;</span>$@<span style=color:#b8bb26>&#34;</span>; <span style=color:#fe8019>do</span> <span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$arg<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>    --force<span style=color:#fe8019>)</span>   force_enable<span style=color:#fe8019>=</span><span style=color:#fabd2f>true</span> ;;
</span></span><span style=display:flex><span>    --delete<span style=color:#fe8019>)</span> delete_enable<span style=color:#fe8019>=</span><span style=color:#fabd2f>true</span> ;;
</span></span><span style=display:flex><span>    *<span style=color:#fe8019>)</span> <span style=color:#fabd2f>echo</span> <span style=color:#b8bb26>&#34;Opsi tidak dikenali.&#34;</span>; <span style=color:#fabd2f>exit</span> <span style=color:#d3869b>1</span> ;;
</span></span><span style=display:flex><span><span style=color:#fe8019>esac</span>; <span style=color:#fe8019>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Pada model ini, kita memanfaatkan variabel <code>$@</code> dan tidak perlu memanggil <code>shift</code> karena tiap iterasinya, FOR loop akan mengkonsumsi semua ekspansi <code>$@</code> satu persatu. Bentuknya menjadi lebih ringkas namun kurang fleksibel.</p><h2 id=validasi>Validasi<a hidden class=anchor aria-hidden=true href=#validasi>#</a></h2><p>Tentunya, setiap pemberian opsi dan/atau <em>positional argument</em> perlu diberlakukan validasi terlebih dahulu. Misalnya script tidak memperbolehkan penggunaan flag/opsi yang sama lebih dari satu, atau jika opsi yang satu sudah diberikan maka opsi yang lain tidak boleh diberikan pula.</p><p>Strategi untuk mengatasi kondisi semacam itu beragam. Diantaranya bisa dengan misalnya opsi yang terakhir diberikan maka itu yang akan dipertimbangkan. Atau pemberian prioritas, atau bahkan script akan error jika bertemu kondisi-kondisi tersebut.</p><p>Hal ini bisa dilakukan langsung pada bagian kondisional CASE atau setelah <em>argument parsing</em> selesai.</p><p>Contohnya pada utilitas <code>mv</code> atau <code>rm</code> pada opsi <code>-i</code> dan <code>-f</code>-nya:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm -i -f file2
</span></span></code></pre></div><p>Opsi <code>-i</code> berfungsi agar perintah <code>rm</code> memberikan <em>prompt</em> sebelum penghapusan file dilakukan. Sedangkan <code>-f</code> adalah opsi yang digunakan agar <code>rm</code> menghapus &ldquo;paksa&rdquo; suatu file tanpa menanyakan/memberitahukan terkait ada/tidaknya file yang dimaksud. Tentu keduanya bertentangan satu sama lain. Bagaimana <code>rm</code> menangani kondisi ini? Yaitu dengan memprioritaskan opsi yang paling akhir.</p><p>Sehingga bisa saja suatu script disusun seperti ini untuk meniru gaya <em>argument parsing</em> pada <code>cp</code>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>[[</span> $# -ne <span style=color:#d3869b>0</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>do</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        -i<span style=color:#fe8019>)</span> option<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;interactive&#34;</span>; <span style=color:#fabd2f>shift</span> ;;
</span></span><span style=display:flex><span>        -f<span style=color:#fe8019>)</span> option<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;force&#34;</span>; <span style=color:#fabd2f>shift</span> ;;
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    <span style=color:#fe8019>esac</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>done</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>dengan demikian, variabel <code>option</code> akan memiliki nilai sesuai dengan opsi yang ditentukan paling akhir.</p><p>Kemudian, suatu script dimana script tersebut memerlukan variabel tertentu agar diset oleh user, namun jika tidak diberikan, variabel tersebut akan terisi dengan nilai <em>default</em>. Misalnya pada tool <code>iptables</code>. Tool tersebut memerlukan ditentukannya nama tabel agar bisa menampilkan semua <em>rules</em>-nya dengan flag <code>-L</code>.</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -t nat -L
</span></span></code></pre></div><p>Jika, opsti <code>-t nat</code> tidak diberikan, maka secara asal, iptables akan menampilkan <em>rules</em> pada tabel filter. Contoh pada script:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#fe8019>while</span> <span style=color:#fe8019>[[</span> $# -ne <span style=color:#d3869b>0</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>do</span>
</span></span><span style=display:flex><span>    <span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        -t<span style=color:#fe8019>)</span> table<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span>$2<span style=color:#b8bb26>&#34;</span>; <span style=color:#fabd2f>shift</span> <span style=color:#d3869b>2</span> ;;
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    <span style=color:#fe8019>esac</span>
</span></span><span style=display:flex><span><span style=color:#fe8019>done</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fe8019>if</span> <span style=color:#fe8019>[[</span> -z <span style=color:#b8bb26>&#34;</span>$table<span style=color:#b8bb26>&#34;</span> <span style=color:#fe8019>]]</span>; <span style=color:#fe8019>then</span>
</span></span><span style=display:flex><span>    table<span style=color:#fe8019>=</span>filter
</span></span><span style=display:flex><span><span style=color:#fe8019>fi</span>
</span></span></code></pre></div><p>atau lebih sederhana, menggunakan <em>parameter expansion</em>:</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#fe8019>case</span> <span style=color:#b8bb26>&#34;</span>$1<span style=color:#b8bb26>&#34;</span> in
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    -t<span style=color:#fe8019>)</span> table<span style=color:#fe8019>=</span><span style=color:#b8bb26>&#34;</span><span style=color:#b8bb26>${</span>2<span style=color:#fe8019>:-</span>filter<span style=color:#b8bb26>}</span><span style=color:#b8bb26>&#34;</span>; <span style=color:#fabd2f>shift</span> <span style=color:#d3869b>2</span> ;;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span><span style=color:#fe8019>esac</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><style>.callout{color:#f7f4ef;background:#3e3e4f;padding:1em 1.25em;border-radius:3px;display:flex;flex-direction:row;margin:20px auto}.callout code{background-color:transparent}.callout-inner{margin-left:1em}r .callout div p{margin:0}@media(max-width:767px){.callout{padding:1.5em .75em 1.5em .6em}.callout-inner{margin-left:.5em}}</style><div class=callout><div>‚òùÔ∏è</div><div class=callout-inner><p>Yang maknanya, jika variabel <code>$2</code> itu <code>UNSET</code> atau bernilai kosong (<em>empty string</em>), maka isi variabel <code>table</code> dengan <em>string</em> <code>filter</code>.</p></div></div><hr><p>Bagaimana dengan bentuk option/flag seperti contoh dibawah ini?</p><div class=highlight><pre tabindex=0 style=color:#ebdbb2;background-color:#282828;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar xvzf archive.tar.gz
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># atau rsync</span>
</span></span><span style=display:flex><span>rsync -avznP source/ user@host:/dest/
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># atau ps</span>
</span></span><span style=display:flex><span>ps aux
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># atau ss/netstat</span>
</span></span><span style=display:flex><span>ss -ant
</span></span><span style=display:flex><span>netstat -patlun
</span></span></code></pre></div><p>Saya serahkan pada pembaca untuk mencari tahu.</p><p>Semoga bermanfaat, <em>barakallahufiikum.</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.annahri.com/tags/bash/>Bash</a></li><li><a href=https://blog.annahri.com/tags/scripting/>Scripting</a></li></ul><nav class=paginav><a class=prev href=https://blog.annahri.com/posts/jurnal-menyelamatkan-partisi-lvm-yang-rusak/><span class=title>¬´ Sebelumnya</span><br><span>Jurnal: Menyelamatkan Partisi LVM Yang Metadatanya Tertimpa</span>
</a><a class=next href=https://blog.annahri.com/posts/belajar-bash-scripting-arguments/><span class=title>Selanjutnya ¬ª</span><br><span>Belajar Bash Scripting: Arguments</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=annahri/blog.annahri.com data-repo-id=423672062 data-category=Announcements data-category-id=DIC_kwDOGUC4_s4CdOMw data-mapping=pathname data-reactions-enabled=0 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=id data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.annahri.com/>Linux & Cloud | blog.annahri.com</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="salin";function s(){t.innerHTML="disalin!",setTimeout(()=>{t.innerHTML="salin"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>